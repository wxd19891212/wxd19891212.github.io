<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaoDong</title>
  
  <subtitle>developer.apple</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.xiaodongwang.com/"/>
  <updated>2018-05-17T13:09:42.947Z</updated>
  <id>http://blog.xiaodongwang.com/</id>
  
  <author>
    <name>XiaoDong Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS GCD信号量（附Demo）</title>
    <link href="http://blog.xiaodongwang.com/2018/05/09/14007/"/>
    <id>http://blog.xiaodongwang.com/2018/05/09/14007/</id>
    <published>2018-05-09T15:14:32.000Z</published>
    <updated>2018-05-17T13:09:42.947Z</updated>
    
    <content type="html"><![CDATA[<p>既然是多线程，就肯定离不开一个关键的东西——Semaphore(信号量)。<br>信号量是一个特殊的变量，程序只能在临界区访问它，也就是说只能对它进行原子操作，而且只允许对它进行请求（P操作）和释放(V操作)。信号量的存在是为了保证多线程资源请求的有序性。<a id="more"></a>不理解的自行复习操作系统。<br>在GCD中，我们用dispatch_semaphore_t来表示信号量，计数为0时等待，计数大于等于1时则无需等待，将信号量减1后直接进行操作。我们使用dispatch_semaphore_create来产生一个Dispatch Semaphore，该函数的参数即为信号量的初始值。</p><p>在GCD中有三个函数是semaphore的操作，分别是：</p><p>1.创建信号量，可以设置信号量的资源数。0表示没有资源，调用<code>dispatch_semaphore_wait</code>会立即等待。<code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</code><br>2.等待信号，可以设置超时参数。该函数返回0表示得到通知，非0表示超时。<code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code><br>3.通知信号，如果等待线程被唤醒则返回非0，否则返回0。<code>dispatch_semaphore_signal(semaphore);</code></p><h1 id="使用场景一-并发队列"><a href="#使用场景一-并发队列" class="headerlink" title="使用场景一:并发队列"></a>使用场景一:并发队列</h1><p>比如现在我每次想执行10个任务。休息两秒。继续执行10个任务。可以这么写.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testSemaphore&#123;</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">10</span>);<span class="comment">//信号总量是10</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<span class="comment">//信号量-1</span></div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,i);</div><div class="line">            sleep(<span class="number">2</span>);</div><div class="line">            dispatch_semaphore_signal(semaphore);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="使用场景二-异步队列中做事，等待回调后执行某件事"><a href="#使用场景二-异步队列中做事，等待回调后执行某件事" class="headerlink" title="使用场景二:异步队列中做事，等待回调后执行某件事"></a>使用场景二:异步队列中做事，等待回调后执行某件事</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) testAsynFinished&#123;</div><div class="line">    __block <span class="built_in">BOOL</span> isok = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    WXDEngine *engine = [[WXDEngine alloc] init];</div><div class="line">    [engine queryCompletion:^(<span class="built_in">BOOL</span> isOpen) &#123;<span class="comment">//sleep了3秒</span></div><div class="line">        isok = isOpen;</div><div class="line">        dispatch_semaphore_signal(sema);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"success!"</span>);</div><div class="line">    &#125; onError:^(<span class="built_in">BOOL</span> isOpen, <span class="keyword">int</span> errorCode) &#123;</div><div class="line">        isok = <span class="literal">NO</span>;</div><div class="line">        dispatch_semaphore_signal(sema);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error!"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"finished"</span>);</div><div class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="使用场景三-生产者，消费者"><a href="#使用场景三-生产者，消费者" class="headerlink" title="使用场景三:生产者，消费者"></a>使用场景三:生产者，消费者</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) testProductAndConsumer&#123;</div><div class="line">    </div><div class="line">    dispatch_semaphore_t sem = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> producerQueue = dispatch_queue_create(<span class="string">"producer"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">//生产者线程跑的队列</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> consumerQueue = dispatch_queue_create(<span class="string">"consumer"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">//消费者线程跑的队列</span></div><div class="line">    </div><div class="line">    __block <span class="keyword">int</span> cakeNumber = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_async</span>(producerQueue,  ^&#123; <span class="comment">//生产者队列</span></div><div class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!dispatch_semaphore_signal(sem))</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Product:生产出了第%d个蛋糕"</span>,++cakeNumber);</div><div class="line">                sleep(<span class="number">1</span>); <span class="comment">//wait for a while</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(consumerQueue,  ^&#123;<span class="comment">//消费者队列</span></div><div class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>*<span class="built_in">NSEC_PER_SEC</span>)))&#123;</div><div class="line">                <span class="keyword">if</span>(cakeNumber &gt; <span class="number">0</span>)&#123;</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"Consumer:拿到了第%d个蛋糕"</span>,cakeNumber--);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实归根结底，中心思想就是通过信号量，来控制线程任务什么时候算作结束，如果不用信号量，请求发出后即认为任务完成，而网络请求又要不同时间，所以会打乱顺序。因此用一个信号量来控制在单个线程操作内，必须等待请求返回，自己要执行的操作完成后，才将信号量+1，这时候一直处于等待的代码也得以执行通过，任务才算作完成。<br>通过这个方法，就可以解决由于网络请求耗时特性而带来的一些意想不到的多线程处理的问题。</p><p><a href="https://github.com/wxd19891212/WXD_GCD_DEMO" target="_blank" rel="external">Demo下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然是多线程，就肯定离不开一个关键的东西——Semaphore(信号量)。&lt;br&gt;信号量是一个特殊的变量，程序只能在临界区访问它，也就是说只能对它进行原子操作，而且只允许对它进行请求（P操作）和释放(V操作)。信号量的存在是为了保证多线程资源请求的有序性。
    
    </summary>
    
      <category term="GCD" scheme="http://blog.xiaodongwang.com/categories/GCD/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/GCD/iOS/"/>
    
    
      <category term="GCD" scheme="http://blog.xiaodongwang.com/tags/GCD/"/>
    
      <category term="并发" scheme="http://blog.xiaodongwang.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="semaphore" scheme="http://blog.xiaodongwang.com/tags/semaphore/"/>
    
  </entry>
  
  <entry>
    <title>用Runtime简单模拟实现KVO（附Demo）</title>
    <link href="http://blog.xiaodongwang.com/2017/10/10/61606/"/>
    <id>http://blog.xiaodongwang.com/2017/10/10/61606/</id>
    <published>2017-10-10T02:14:32.000Z</published>
    <updated>2018-05-17T12:18:27.351Z</updated>
    
    <content type="html"><![CDATA[<p>KVO相信iOS开发者们都听说过,在面试中也会被常常问到,但是呢对于KVO来说更多的事情是由系统来做的,依赖于运行时,相对于Notification,delegate来说是比较简单的,提供观察属性旧值与新值,以下单纯的说下自己对KVO的实现原理粗略理解,用Runtime简单模拟实现KVO。<br><a id="more"></a><br><!-- TOC --></p><h1 id="KVO是什么"><a href="#KVO是什么" class="headerlink" title="KVO是什么"></a>KVO是什么</h1><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>KVO 在 Apple 中的 API 文档如下：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p></blockquote><p>KVO 的实现依赖于 Objective-C 强大的 Runtime，从以上 Apple 的文档可以看出苹果对于 KVO 机制的实现是一笔带过，而具体的细节没有过多的描述，但是我们可以通过 Runtime 的所提供的方法去探索关于KVO 机制的底层实现原理。</p><h2 id="基本的原理："><a href="#基本的原理：" class="headerlink" title="基本的原理："></a>基本的原理：</h2><p>KVO 是基于 runtime 运行时来实现的，当你观察了某个对象的属性，内部会生成一个该对象所属类的子类，然后从写被观察属性的setter方法，当然在重写的方法中会调用父类的setter方法从而不会影响框架使用者的逻辑，之后会将该对象的isa指针指向新创建的这个类，最后会重写-(Class)class;方法，让使用者通过[obj class]查看当前对象所属类的时候会返回其父类，达到移花接木的目的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class-withOutKVO: %@ \n"</span>, object_getClass(<span class="keyword">self</span>.testObj));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"setterAdress-withOutKVO: %p \n"</span>, [<span class="keyword">self</span>.testObj methodForSelector:<span class="keyword">@selector</span>(setName:)]);</div><div class="line">     </div><div class="line">[<span class="keyword">self</span>.testObj addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> |<span class="built_in">NSKeyValueObservingOptionOld</span> context: <span class="literal">nil</span>];</div><div class="line">[<span class="keyword">self</span>.testObj addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> |<span class="built_in">NSKeyValueObservingOptionOld</span> context: <span class="literal">nil</span>];</div><div class="line">     </div><div class="line">     </div><div class="line"><span class="keyword">self</span>.testObj.name = <span class="string">@"xxxx"</span>;</div><div class="line"><span class="keyword">self</span>.testObj.age = <span class="number">12</span>;</div><div class="line">     </div><div class="line">     </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class-addKVO: %@ \n"</span>, object_getClass(<span class="keyword">self</span>.testObj));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"setterAdress-addKVO: %p \n"</span>, [<span class="keyword">self</span>.testObj methodForSelector:<span class="keyword">@selector</span>(setName:)]);</div><div class="line">     </div><div class="line">[<span class="keyword">self</span>.testObj removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</div><div class="line">[<span class="keyword">self</span>.testObj removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</div><div class="line">     </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class-removeKVO: %@"</span>, object_getClass(<span class="keyword">self</span>.testObj));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"setterAdress-removeKVO: %p \n"</span>, [<span class="keyword">self</span>.testObj methodForSelector:<span class="keyword">@selector</span>(setName:)]);</div></pre></td></tr></table></figure></p><p>看到了么，我们使用object_getClass ()方法成功躲开了 KVO 的障眼法，发现添加观察过后，_obj的类变成了NSKVONotifying_TestObj，在移除观察过后，_obj的类又变回TestObj。同时，我们还观察了setAName:方法的地址，发现同样是有变化，同样验证了重写setter方法的逻辑。</p><h2 id="深入剖析："><a href="#深入剖析：" class="headerlink" title="深入剖析："></a>深入剖析：</h2><p>关键代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)wxd_coreLogicWithTarget:(<span class="keyword">id</span>)target getterName:(<span class="built_in">NSString</span> *)getterName &#123;</div><div class="line">    <span class="comment">//若 setter 不存在,根据属性名（也是getter的方法名）生成setter的方法名</span></div><div class="line">    <span class="built_in">NSString</span> *setterName = setterNameFromGetterName(getterName);</div><div class="line">    SEL setterSel = <span class="built_in">NSSelectorFromString</span>(setterName);</div><div class="line">    Method setterMethod = class_getInstanceMethod(object_getClass(target), setterSel);</div><div class="line">    <span class="keyword">if</span> (!setterMethod) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    <span class="comment">//创建派生类并且更改 isa 指针</span></div><div class="line">    [<span class="keyword">self</span> wxd_creatSubClassWithTarget:target];</div><div class="line">    <span class="comment">//给派生类添加 setter 方法体</span></div><div class="line">    <span class="keyword">if</span> (!classHasSel(object_getClass(target), setterSel)) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(setterMethod);</div><div class="line">        <span class="keyword">return</span> class_addMethod(object_getClass(target), setterSel, (IMP)wxd_kvo_setter, types);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建派生类并且更改 isa 指针</span></div><div class="line">- (<span class="keyword">void</span>)wxd_creatSubClassWithTarget:(<span class="keyword">id</span>)target &#123;</div><div class="line">    <span class="comment">//获取被观察者的类</span></div><div class="line">    Class nowClass = object_getClass(target);</div><div class="line">    <span class="built_in">NSString</span> *nowClass_name = <span class="built_in">NSStringFromClass</span>(nowClass);</div><div class="line">    <span class="comment">//如果isa指针已经指向子类返回</span></div><div class="line">    <span class="keyword">if</span> ([nowClass_name hasPrefix:kPrefixOfWXDKVO]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//动态生成新的子类类名</span></div><div class="line">    <span class="built_in">NSString</span> *subClass_name = [kPrefixOfWXDKVO stringByAppendingString:nowClass_name];</div><div class="line">    Class subClass = <span class="built_in">NSClassFromString</span>(subClass_name);</div><div class="line">    <span class="comment">//若派生类存在</span></div><div class="line">    <span class="keyword">if</span> (subClass) &#123;</div><div class="line">        <span class="comment">//将该对象 isa 指针指向派生类</span></div><div class="line">        object_setClass(target, subClass);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加派生类，并且给派生类添加 class 方法体，其中nowClass是传进来的目标类</span></div><div class="line">    subClass = objc_allocateClassPair(nowClass, subClass_name.UTF8String, <span class="number">0</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(class_getInstanceMethod(nowClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>)));</div><div class="line">    IMP class_imp = imp_implementationWithBlock(^Class (<span class="keyword">id</span> target)&#123;</div><div class="line">        <span class="keyword">return</span> class_getSuperclass(object_getClass(target));</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    class_addMethod(subClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>), class_imp, types);</div><div class="line">    <span class="comment">//注册该类</span></div><div class="line">    objc_registerClassPair(subClass);</div><div class="line">    </div><div class="line">    <span class="comment">//将该对象 isa 指针指向派生类</span></div><div class="line">    object_setClass(target, subClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="回调相关问题"><a href="#回调相关问题" class="headerlink" title="回调相关问题"></a>回调相关问题</h1><p>接下来就是回调的情况了，在重写的setter里面逻辑是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> wxd_kvo_setter (<span class="keyword">id</span> taget, SEL sel, <span class="keyword">id</span> p0) &#123;</div><div class="line">    <span class="comment">//拿到调用父类方法之前的值</span></div><div class="line">    <span class="built_in">NSString</span> *getterName = getterNameFromSetterName(<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">    <span class="keyword">id</span> old = [taget valueForKey:getterName];</div><div class="line">    callBack(taget, <span class="literal">nil</span>, old, getterName, <span class="literal">YES</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//给父类发送消息</span></div><div class="line">    <span class="keyword">struct</span> objc_super sup = &#123;</div><div class="line">        .receiver = taget,</div><div class="line">        .super_class = class_getSuperclass(object_getClass(taget))</div><div class="line">    &#125;;</div><div class="line">    ((<span class="keyword">void</span>(*)(<span class="keyword">struct</span> objc_super *, SEL, <span class="keyword">id</span>)) objc_msgSendSuper)(&amp;sup, sel, p0);</div><div class="line">    </div><div class="line">    callBack(taget, p0, old, getterName, <span class="literal">NO</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上介绍了 KVO 的实现原理并自己实现了一个简单的 KVO，源码 <a href="https://github.com/wxd19891212/WXD_KVO_DEMO" target="_blank" rel="external">KVO Demo</a>，感兴趣的可以下载下来看看。<br>实际上 KVO 的实现还是很复杂的，要考虑到很多地方，复杂的实现网上有相关代码，或者看 KVO 源码了解一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KVO相信iOS开发者们都听说过,在面试中也会被常常问到,但是呢对于KVO来说更多的事情是由系统来做的,依赖于运行时,相对于Notification,delegate来说是比较简单的,提供观察属性旧值与新值,以下单纯的说下自己对KVO的实现原理粗略理解,用Runtime简单模拟实现KVO。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="减耦合" scheme="http://blog.xiaodongwang.com/tags/%E5%87%8F%E8%80%A6%E5%90%88/"/>
    
      <category term="KVO" scheme="http://blog.xiaodongwang.com/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS Runtime 学习总结（附Demo）</title>
    <link href="http://blog.xiaodongwang.com/2017/09/14/522/"/>
    <id>http://blog.xiaodongwang.com/2017/09/14/522/</id>
    <published>2017-09-14T15:14:32.000Z</published>
    <updated>2018-05-17T12:18:06.769Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。<br><a id="more"></a><br><!-- TOC --></p><h1 id="消息传递（Messaging）"><a href="#消息传递（Messaging）" class="headerlink" title="消息传递（Messaging）"></a>消息传递（Messaging）</h1><p>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。</p><p>事实上，在编译时你写的 Objective-C 函数调用的语法都会被翻译成一个 C 的函数调用 - objc_msgSend() 。比如，下面两行代码就是等价的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[array insertObject:foo atIndex:<span class="number">5</span>];</div><div class="line">objc_msgSend(array, <span class="keyword">@selector</span>(insertObject:atIndex:), foo, <span class="number">5</span>);</div></pre></td></tr></table></figure><p>消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。</p><h1 id="objc-object-objc-class-以及-Ojbc-method"><a href="#objc-object-objc-class-以及-Ojbc-method" class="headerlink" title="objc_object, objc_class 以及 Ojbc_method"></a>objc_object, objc_class 以及 Ojbc_method</h1><p>在 Objective-C 中，类、对象和方法都是一个 C 的结构体，从 objc/objc.h 头文件中，我们可以找到他们的定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">long</span> version;</div><div class="line">    <span class="keyword">long</span> info;</div><div class="line">    <span class="keyword">long</span> instance_size;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</div><div class="line">    **<span class="keyword">struct</span> objc_method_list **methodLists**;</div><div class="line">    **<span class="keyword">struct</span> objc_cache *cache**;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> objc_method_list &#123;  </div><div class="line">    <span class="keyword">struct</span> objc_method_list *obsolete;</div><div class="line">    <span class="keyword">int</span> method_count;</div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> objc_method &#123;  </div><div class="line">    SEL method_name;</div><div class="line">    <span class="keyword">char</span> *method_types;    <span class="comment">/* a string representing argument/return types */</span></div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串 (见 Type Encoding) ，以及函数的实现IMP。</p><p>从这些定义中可以看出发送一条消息也就 objc_msgSend 做了什么事。举 objc_msgSend(obj, testMethod) 这个例子来说：</p><p>1.首先，通过 obj 的 isa 指针找到它的 class ;//找到类对象<br>2.在 class 的 method list 找 testMethod ;<br>3.如果 class 中没到 testMethod，继续往它的 superclass 中找 ;<br>4.一旦找到 testMethod 这个函数，就去执行它的实现IMP .<br>5.转发IMP的return值</p><p>但这种实现有个问题，效率低。但一个 class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 testMethod 之后，把 testMethod 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 testMethod 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.</p><p>下面讲讲消息传递用到的一些概念：</p><ul><li>类对象(objc_class)</li><li>实例(objc_object)</li><li>类(Meta Class)</li><li>Method(objc_method)</li><li>SEL(objc_selector)</li><li>IMP</li><li>类缓存(objc_cache)</li><li>Category(objc_category)</li></ul><h2 id="类对象-objc-class"><a href="#类对象-objc-class" class="headerlink" title="类对象(objc_class)"></a>类对象(objc_class)</h2><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure><p>struct objc_class结构体定义了很多变量，通过命名不难发现，<br>结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，<br>一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，<br>该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。</p><h2 id="实例-objc-object"><a href="#实例-objc-object" class="headerlink" title="实例(objc_object)"></a>实例(objc_object)</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Represents an instance of a class. </span></div><div class="line"><span class="keyword">struct</span> objc_object &#123; </div><div class="line">Class isa OBJC_ISA_AVAILABILITY; </div><div class="line">&#125;; </div><div class="line"><span class="comment">/// A pointer to an instance of a class. </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure><p>类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？<br>就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，<br>元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:</p><p><img src="http://oxyk7k4jh.bkt.clouddn.com/2018-05-14-301129-cc9c0a7ffb147fed.png" alt="结构"></p><h2 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h2><p>通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。</p><p>元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。</p><p>任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p><h2 id="Method-objc-method"><a href="#Method-objc-method" class="headerlink" title="Method(objc_method)"></a>Method(objc_method)</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">runtime.h</div><div class="line"><span class="comment">/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">   SEL method_name                                          OBJC2_UNAVAILABLE;<span class="comment">//方法名</span></div><div class="line">   <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;<span class="comment">//方法类型</span></div><div class="line">   IMP method_imp                                           OBJC2_UNAVAILABLE;<span class="comment">//方法实现</span></div></pre></td></tr></table></figure><p>在这个结构体中，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。</p><h3 id="SEL-objc-selector"><a href="#SEL-objc-selector" class="headerlink" title="SEL(objc_selector)"></a>SEL(objc_selector)</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Objc.h</div><div class="line"><span class="comment">/// An opaque type that represents a method selector.代表一个方法的不透明类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure><p>objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> SEL selector;</div></pre></td></tr></table></figure><p>可以看到selector是SEL的一个实例。</p><blockquote><p>A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.</p></blockquote><p>其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。</p><p>selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条：</p><ul><li>同一个类，selector不能重复</li><li>不同的类，selector可以重复</li></ul><p>这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。</p><p>在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。</p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>就是指向最终实现程序的内存地址的指针。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation.  指向一个方法实现的指针</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...); </div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure></p><p>在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p><h2 id="类缓存-objc-cache"><a href="#类缓存-objc-cache" class="headerlink" title="类缓存(objc_cache)"></a>类缓存(objc_cache)</h2><p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。</p><p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。</p><h2 id="Category-objc-category"><a href="#Category-objc-category" class="headerlink" title="Category(objc_category)"></a>Category(objc_category)</h2><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> category_t &#123;</div><div class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//是指 class_name 而不是 category_name。</span></div><div class="line">   classref_t cls;<span class="comment">//要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。</span></div><div class="line">   <span class="keyword">struct</span> method_list_t *instanceMethods;<span class="comment">//category中所有给类添加的实例方法的列表</span></div><div class="line">   <span class="keyword">struct</span> method_list_t *classMethods;<span class="comment">//category中所有添加的类方法的列表。</span></div><div class="line">   <span class="keyword">struct</span> protocol_list_t *protocols;<span class="comment">//category实现的所有协议的列表</span></div><div class="line">   <span class="keyword">struct</span> property_list_t *instanceProperties;<span class="comment">//表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</p><h1 id="动态方法解析和转发"><a href="#动态方法解析和转发" class="headerlink" title="动态方法解析和转发"></a>动态方法解析和转发</h1><p>在上面的例子中，如果 testMethod 没有找到会发生什么？通常情况下，程序会在运行时挂掉并抛出 unrecognized selector sent to … 的异常。但在异常抛出前，Objective-C 的运行时会给你三次拯救程序的机会：</p><p>1.Method resolution<br>2.Fast forwarding<br>3.Normal forwarding</p><p>首先，Objective-C 运行时会调用 <code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES， 那运行时系统就会重新启动一次消息发送的过程。还是以 testMethod 为例，你可以这么实现：</p><h2 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">void</span> testMethodIMP(<span class="keyword">id</span> obj, SEL _cmd)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing testMethod"</span>);<span class="comment">//新的testMethod函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">     <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(testMethod:)) &#123;</div><div class="line">     <span class="comment">//https://www.jianshu.com/p/54c190542aa8  为什么object_getClass(obj)与[OBJ class]返回的指针不同</span></div><div class="line">     </div><div class="line">     Class _clsA = object_getClass(<span class="keyword">self</span>);<span class="comment">//返回isa指针</span></div><div class="line">     Class _clsB = [<span class="keyword">self</span> <span class="keyword">class</span>];<span class="comment">//返回自己</span></div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *types = <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(<span class="keyword">@selector</span>(testMethod:)));</div><div class="line">     class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)testMethodIMP, types);</div><div class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果 resolve 方法返回 NO ，运行时就会移到下一步：消息转发（Message Forwarding）。</p><h2 id="Fast-forwarding"><a href="#Fast-forwarding" class="headerlink" title="Fast forwarding"></a>Fast forwarding</h2><p>如果目标对象实现了 <code>-forwardingTargetForSelector:</code> ，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">     <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(testMethod:)) &#123;</div><div class="line">     <span class="keyword">return</span> [Person new];<span class="comment">//返回Person对象，让Person对象接收这个消息</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">     </div><div class="line">    <span class="comment">//return nil;//返回nil，进入下一步转发</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只要这个方法返回的不是 nil 和 self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续 Normal Fowarding 。</p><p>这里叫 Fast ，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个 NSInvocation 对象，所以相对更快点。</p><h2 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h2><p>这一步是 Runtime 最后一次给你挽救的机会。首先它会发送 <code>-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型。如果 <code>-methodSignatureForSelector:</code> 返回 nil ，Runtime 则会发出 <code>-doesNotRecognizeSelector:</code> 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime 就会创建一个 NSInvocation 对象并发送 <code>-forwardInvocation:</code> 消息给目标对象。</p><p>NSInvocation 实际上就是对一个消息的描述，包括selector 以及参数等信息。所以你可以在 <code>-forwardInvocation:</code> 里修改传进来的 NSInvocation 对象，然后发送 <code>-invokeWithTarget:</code> 消息给它，传进去一个新的目标：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(testMethod:)) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(class_getInstanceMethod(object_getClass([Person new]), <span class="keyword">@selector</span>(testMethod:)));</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:types];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">    SEL sel = anInvocation.selector;</div><div class="line">    Person *p = [Person new];</div><div class="line">    <span class="keyword">if</span> ([p respondsToSelector:sel]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:p];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Cocoa 里很多地方都利用到了消息传递机制来对语言进行扩展，如 Proxies、NSUndoManager 跟 Responder Chain。NSProxy 就是专门用来作为代理转发消息的；NSUndoManager 截取一个消息之后再发送；而 Responder Chain 保证一个消息转发给合适的响应者。</p><h1 id="Method-Swizzling和AOP"><a href="#Method-Swizzling和AOP" class="headerlink" title="Method Swizzling和AOP"></a>Method Swizzling和AOP</h1><p>下面实现一个替换ViewController的viewDidLoad方法的例子</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">     Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">     <span class="comment">//SEL originalSelector = @selector(viewDidLoad);</span></div><div class="line">     SEL originalSelector = <span class="keyword">@selector</span>(viewDidLoad);</div><div class="line">     SEL swizzledSelector = <span class="keyword">@selector</span>(wxdViewDidLoad);</div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line">     </div><div class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">     class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">     method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">     &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Aspect-Oriented-Programming-（面向切面编程）"><a href="#Aspect-Oriented-Programming-（面向切面编程）" class="headerlink" title="Aspect Oriented Programming （面向切面编程）"></a>Aspect Oriented Programming （面向切面编程）</h2><p>在 Objective-C 的世界里，这句话意思就是利用 Runtime 特性给指定的方法添加自定义代码。有很多方式可以实现 AOP ，Method Swizzling 就是其中之一。而且幸运的是，目前已经有一些第三方库可以让你不需要了解 Runtime ，就能直接开始使用 AOP 。<br>Aspects 就是一个不错的 AOP 库，封装了 Runtime ， Method Swizzling 这些黑色技巧，只提供两个简单的API：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - Public Aspects API</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">    <span class="keyword">return</span> aspect_add((<span class="keyword">id</span>)<span class="keyword">self</span>, selector, options, block, error);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// @return A token which allows to later deregister the aspect.</span></div><div class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">    <span class="keyword">return</span> aspect_add(<span class="keyword">self</span>, selector, options, block, error);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 Aspects 提供的 API，我们之前的例子会进化成这个样子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> aspect_hookSelector:<span class="keyword">@selector</span>(viewDidLoad) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</div><div class="line">   <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([[aspectInfo instance] <span class="keyword">class</span>]);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@""</span>);</div><div class="line">   [[aspectInfo instance] wxdViewDidLoad];</div><div class="line">&#125; error:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/wxd19891212/WXD_Runtime_DEMO" target="_blank" rel="external">Demo</a><br>利用 objective-C Runtime 特性和 Aspect Oriented Programming ，我们可以把琐碎事务的逻辑从主逻辑中分离出来，作为单独的模块。它是对面向对象编程模式的一个补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。&lt;br&gt;
    
    </summary>
    
      <category term="DataCache" scheme="http://blog.xiaodongwang.com/categories/DataCache/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/DataCache/iOS/"/>
    
    
      <category term="运行时" scheme="http://blog.xiaodongwang.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
      <category term="Runtime" scheme="http://blog.xiaodongwang.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>评论系统跟换为Gitment</title>
    <link href="http://blog.xiaodongwang.com/2017/08/05/34074/"/>
    <id>http://blog.xiaodongwang.com/2017/08/05/34074/</id>
    <published>2017-08-05T09:00:32.000Z</published>
    <updated>2018-03-09T06:42:21.931Z</updated>
    
    <content type="html"><![CDATA[<p><code>Gitment</code> 是作者<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="external">imsun</a>实现的一款基于 <code>GitHub Issues</code> 的评论系统。<br><a id="more"></a><br>支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 <code>Markdown</code> / <code>GFM</code> 和代码高亮支持。尤为适合各种基于 <code>GitHub Pages</code> 的静态博客或项目页面。<br>本博客评论系统已迁移至 <code>Gitment</code>，参考作者的介绍部署成功，有兴趣的可以<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="external">阅读原文</a>。</p><!--more-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Gitment&lt;/code&gt; 是作者&lt;a href=&quot;https://imsun.net/posts/gitment-introduction/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;imsun&lt;/a&gt;实现的一款基于 &lt;code&gt;GitHub Issues&lt;/code&gt; 的评论系统。&lt;br&gt;
    
    </summary>
    
      <category term="记录" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="博客" scheme="http://blog.xiaodongwang.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Gitment" scheme="http://blog.xiaodongwang.com/tags/Gitment/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用架构学习笔记</title>
    <link href="http://blog.xiaodongwang.com/2017/07/07/6620/"/>
    <id>http://blog.xiaodongwang.com/2017/07/07/6620/</id>
    <published>2017-07-07T15:14:32.000Z</published>
    <updated>2018-05-17T12:43:27.587Z</updated>
    
    <content type="html"><![CDATA[<p>我们常见的分层架构，有三层架构：视图层、业务层、数据层。也有四层架构：视图层、业务层、网络层、本地数据层。<br>这里说三层、四层，跟TCP/IP所谓的五层或者七层不是同一种概念。再具体说就是：你的架构在逻辑上设计的是几层那就是几层，具体每一层的名称和作用，没有特定的规范, 这主要是针对模块分类而言的。<br><a id="more"></a><br>也有说MVC架构，MVVM架构的，这种层次划分，主要是针对数据流动的方向而言的。<br>在实际情况中，针对数据流动方向做的设计和针对模块分类做的设计是会放在一起的，也就是说，一个MVC架构可以是四层：展现层、业务层、网络层、本地数据层。<br>那么，为什么我要说这个？<br>大概在五六年前，业界很流行三层架构这个术语。然后各种文档资料漫天的三层架构，并且喜欢把它与MVC放在一起说，MVC三层架构/三层架构MVC，以至于很多人就会认为三层架构就是MVC，MVC就是三层架构。其实不是的。三层架构里面其实没有Controller的概念，而且三层架构描述的侧重点是模块之间的逻辑关系。MVC有Controller的概念，它描述的侧重点在于数据流动方向。</p><blockquote><p>好，为什么流行起来的是三层架构，而不是四层架构或五层架构？</p></blockquote><p>因为所有的模块角色只会有三种：数据管理者、数据加工者、数据展示者，意思也就是，笼统说来，软件只会有三层，每一层扮演一个角色。其他的第四层第五层，一般都是这三层里面的其中之一分出来的，最后都能归纳进这三层的某一层中去，所以用三层架构来描述就比较普遍。</p><p>1.视图层设计方案<br>2.网络层设计方案<br>3.本地持久化方案<br>4.动态部署方案<br>上面这四大点，稍微细说一下就是：</p><ul><li>页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？</li><li>如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？</li><li>当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？</li><li>iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？</li></ul><p>一个好的架构</p><ul><li>遵循代码规范代码，分类明确(没有难以区分模块的文件夹或模块)</li><li>注释明了, 逻辑清晰, 不用文档，或很少文档，就能让业务方上手</li><li>思路和方法要统一，尽量不要多元</li><li>没有横向依赖，尽可能少的跨层访问</li><li>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件</li><li>易测试，易拓展</li><li>保持一定量的超前性</li><li>接口少，接口参数少</li><li>低内存，高性能</li></ul><blockquote><p>遵循代码规范代码，分类明确(没有难以区分模块的文件夹或模块)</p></blockquote><p>代码整齐是每一个工程师的基本素质，先不说你搞定这个问题的方案有多好，解决速度有多快，如果代码不整齐，一切都白搭。因为你的代码是要给别人看的，你自己也要看。如果哪一天架构有修改，正好改到这个地方，你很容易自己都看不懂。另外，破窗理论提醒我们，如果代码不整齐分类不明确，整个架构会随着一次一次的拓展而越来越混乱。<br>分类明确的字面意思大家一定都了解，但还有一个另外的意思，那就是：不要让一个类或者一个模块做两种不同的事情。如果有类或某模块做了两种不同的事情，一方面不适合未来拓展，另一方面也会造成分类困难。<br>不要搞Common，Core这些东西。每家公司的架构代码库里面，最恶心的一定是这两个名字命名的文件夹，我这么说一定不会错。不要开Common，Core这样的文件夹，开了之后后来者一定会把这个地方搞得一团糟，最终变成Common也不Common，Core也不Core。要记住，架构是不断成长的，是会不断变化的。不是每次成长每次变化，都是由你去实现的。如果真有什么东西特别小，那就索性为了他单独开辟一个模块就好了，小就小点，关键是要有序。</p><blockquote><p>不用文档，或很少文档，就能让业务方上手</p></blockquote><p>谁特么会去看文档啊，业务方他们已经被产品经理逼得很忙了。所以你要尽可能让你的API名字可读性强，对于iOS来说，objc这门语言的特性把这个做到了极致，函数名长就长一点，不要紧。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">好的函数名：</div><div class="line">    - (<span class="built_in">NSDictionary</span> *)exifDataOfImage:(<span class="built_in">UIImage</span> *)image atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"></div><div class="line">坏的函数名：</div><div class="line">    - (<span class="keyword">id</span>)exifData:(<span class="built_in">UIImage</span> *)image position:(<span class="keyword">id</span>)indexPath callback:(<span class="keyword">id</span>&lt;ErrorDelegate&gt;)delegate;</div><div class="line"></div><div class="line">为什么坏？</div><div class="line">    <span class="number">1.</span> 不要直接返回<span class="keyword">id</span>或者传入<span class="keyword">id</span>，实在不行，用<span class="keyword">id</span>&lt;protocol&gt;也比<span class="keyword">id</span>好。如果连这个都做不到，你要好好考虑你的架构是不是有问题。</div><div class="line">    <span class="number">2.</span> 要告知业务方要传的东西是什么，比如要传Image，那就写上ofImage。如果要传位置，那就要写上IndexPath，而不是用position这么笼统的东西</div><div class="line">    <span class="number">3.</span> 没有任何理由要把delegate作为参数传进去，一定不会有任何情况不得不这么做的。而且delegate这个参数根本不是这个函数要解决的问题的充要条件，如果你发现你不得不这么做，那一定是架构有问题！</div></pre></td></tr></table></figure><blockquote><p>思路和方法要统一，尽量不要多元</p></blockquote><p>解决一个问题会有很多种方案，但是一旦确定了一种方案，就不要在另一个地方采用别的方案了。也就是做架构的时候，你得时刻记住当初你决定要处理这样类型的问题的方案是什么，以及你的初衷是什么，不要摇摆不定。<br>另外，你当初设立这个模块一定是有想法有原因的，要记录下你的解决思路，不要到时候换个地方你又灵光一现啥的，引入了其他方案，从而导致异构。<br>要是一个框架里面解决同一种类似的问题有各种五花八门的方法或者类，我觉得做这个架构的架构师一定是自己都没想清楚就开始搞了。</p><blockquote><p>没有横向依赖，万不得已不出现跨层访问</p></blockquote><p>没有横向依赖是很重要的，这决定了你将来要对这个架构做修补所需要的成本有多大。要做到没有横向依赖，这是很考验架构师的模块分类能力和是否熟悉业务的。<br>跨层访问是指数据流向了跟自己没有对接关系的模块。有的时候跨层访问是不可避免的，比如网络底层里面信号从2G变成了3G变成了4G，这是有可能需要跨层通知到View的。但这种情况不多，一旦出现就要想尽一切办法在本层搞定或者交给上层或者下层搞定，尽量不要出现跨层的情况。跨层访问同样也会增加耦合度，当某一层需要整体替换的时候，牵涉面就会很大。</p><blockquote><p>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件</p></blockquote><p>把这点做好，很依赖于架构师的经验。架构师必须要有能力区分哪些情况需要限制灵活性，哪些情况需要创造灵活性。比如对于Core Data技术栈来说，ManagedObject理论上是可以出现在任何地方的，那就意味着任何地方都可以修改ManagedObject，这就导致ManagedObjectContext在同步修改的时候把各种不同来源的修改同步进去。这时候就需要限制灵活性，只对外公开一个修改接口，不暴露任何ManagedObject在外面。<br>如果是设计一个ABTest相关的API的时候，我们又希望增加它的灵活性。使得业务方不光可以通过Target-Action的模式实现ABtest，也要可以通过Block的方式实现ABTest，要尽可能满足灵活性，减少业务方的使用成本。</p><blockquote><p>易测试易拓展</p></blockquote><p>老生常谈，要实现易测试易拓展，那就要提高模块化程度，尽可能减少依赖关系，便于mock。另外，如果是高度模块化的架构，拓展起来将会是一件非常容易的事情。</p><blockquote><p>保持一定量的超前性</p></blockquote><p>这一点能看出架构师是否关注行业动态，是否能准确把握技术走向。保持适度的技术上的超前性，能够使得你的架构更新变得相对轻松。<br>另外，这里的超前性也不光是技术上的，还有产品上的。谁说架构师就不需要跟产品经理打交道了，没事多跟产品经理聊聊天，听听他对产品未来走向的畅想，你就可以在合理的地方为他的畅想留一条路子。同时，在创业公司的环境下，很多产品需求其实只是为了赶产品进度而产生的妥协方案，最后还是会转到正轨的。这时候业务方可以不实现转到正规的方案，但是架构这边，是一定要为这种可预知的改变做准备的。</p><blockquote><p>接口少，接口参数少</p></blockquote><p>越少的接口越少的参数，就能越降低业务方的使用成本。当然，充要条件还是要满足的，如何在满足充要条件的情况下尽可能地减少接口和参数数量，这就能看出架构师的功力有多深厚了。</p><blockquote><p>高性能</p></blockquote><p>为什么高性能排在最后一位？<br>高性能非常重要，但是在客户端架构中，它不是第一考虑因素。原因有下：</p><ul><li>客户端业务变化非常之快，做架构时首要考虑因素应当是便于业务方快速满足产品需求，因此需要尽可能提供简单易用效果好的接口给业务方，而不是提供高性能的接口给业务方。</li><li>苹果平台的性能非常之棒，正常情况下很少会出现由于性能不够导致的用户体验问题。</li><li>苹果平台的优化手段相对有限，甚至于有些时候即便动用了无所不用其极的手段乃至不择手段牺牲了稳定性，性能提高很有可能也只不过是100ms到90ms的差距。10%的性能提升对于服务端来说很不错了，因为服务端动不动就是几十万上百万的访问量，几十万上百万个10ms是很可观的。但是对于客户端的用户来说，他无法感知这10ms的差别，如果从10s优化成9s用户还是有一定感知的，但是100ms变90ms，我觉得吧，还是别折腾了。</li></ul><p>但是！不重要不代表用不着去做，关于性能优化的东西，我会对应放到各系列文章里面去。比如网络层优化，那就会在网络层方案的那篇文章里面去写，对应每层架构都有每层架构的不同优化方案，我都会在各自文章里面一一细说。</p><h1 id="一、视图层设计方案"><a href="#一、视图层设计方案" class="headerlink" title="一、视图层设计方案"></a>一、视图层设计方案</h1><p>一般来说，一个不够好的View层架构，主要原因有以下五种：<br>1.代码混乱不规范<br>2.过多继承导致的复杂依赖关系<br>3.模块化程度不够高，组件粒度不够细<br>4.横向依赖<br>5.架构设计失去传承</p><h2 id="View层的代码结构规范"><a href="#View层的代码结构规范" class="headerlink" title="View层的代码结构规范"></a>View层的代码结构规范</h2><p>制定代码规范严格来讲不属于View层架构的事情，但它对View层架构未来的影响会比较大，也是属于架构师在设计View层架构时需要考虑的事情。制定View层规范的重要性在于：<br>1.提高业务方View层的可读性可维护性<br>2.防止业务代码对架构产生腐蚀<br>3.确保传承<br>4.保持架构发展的方向不轻易被不合理的意见所左右</p><p>最后，什么是优秀的架构，这的确是一个非常艰难的话题。万能药是不存在的。我不认为有某种架构能够解决所有问题，我觉得应该根据从客户那里收集的需求和用例来考虑架构的事情。因此，根据需求，架构很可能会与我所使用的完全不同。现在，我默认会使用 MVVM 架构，而今后，ReSwift 或者其他架构可能会更加合适。编程的好处就在于我们每天都需要学习，两年后我的观点可能与现在大相径庭。如果不是这样的话，那么我就会担心是不是我学得东西还不够多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常见的分层架构，有三层架构：视图层、业务层、数据层。也有四层架构：视图层、业务层、网络层、本地数据层。&lt;br&gt;这里说三层、四层，跟TCP/IP所谓的五层或者七层不是同一种概念。再具体说就是：你的架构在逻辑上设计的是几层那就是几层，具体每一层的名称和作用，没有特定的规范, 这主要是针对模块分类而言的。&lt;br&gt;
    
    </summary>
    
      <category term="Arch" scheme="http://blog.xiaodongwang.com/categories/Arch/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/Arch/iOS/"/>
    
    
      <category term="thoughts" scheme="http://blog.xiaodongwang.com/tags/thoughts/"/>
    
      <category term="iOS架构" scheme="http://blog.xiaodongwang.com/tags/iOS%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之抽象工厂（三）</title>
    <link href="http://blog.xiaodongwang.com/2017/06/08/2/"/>
    <id>http://blog.xiaodongwang.com/2017/06/08/2/</id>
    <published>2017-06-08T15:14:32.000Z</published>
    <updated>2018-05-10T03:11:17.765Z</updated>
    
    <content type="html"><![CDATA[<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<a id="more"></a></p><h1 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h1><table><thead><tr><th>组成（角色）</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品族（AbstractProduct）</td><td>抽象产品的父类</td><td>描述抽象产品的公共接口</td></tr><tr><td>抽象产品（Product）</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品（Concrete Product）</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂（Creator）</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂（Concrete Creator）</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td></tr></tbody></table><p><img src="http://oxyk7k4jh.bkt.clouddn.com/2018-04-16-1523417544034.jpg" alt="抽象工厂UML"></p><h1 id="示例结构"><a href="#示例结构" class="headerlink" title="示例结构"></a>示例结构</h1><table><thead><tr><th>组成（角色）</th><th>作用</th><th>继承</th><th>方法</th></tr></thead><tbody><tr><td>SQLServerUser</td><td>SQLServer操作用户表对象</td><td>继承IUser协议</td><td>用户表（增加一条记录，得到用户表一条记录）</td></tr><tr><td>SQLServerDepartment</td><td>SQLServer操作部门表对象</td><td>继承IDepartment协议</td><td>部门表（增加一条记录，得到部门表一条记录）</td></tr><tr><td>AccessUser</td><td>Access操作用户表对象</td><td>继承IUser协议</td><td>用户表（增加一条记录，得到用户表一条记录）</td></tr><tr><td>AccessDepartment</td><td>Access操作部门表对象</td><td>继承IDepartment协议</td><td>部门表（增加一条记录，得到部门表一条记录）</td></tr><tr><td>SQLServerFactory</td><td>创建用于访问SQLServer对象的工厂类</td><td>继承IFactory协议</td><td>创建用于访问用户的对象，创建用于访问部门的对象</td></tr><tr><td>AccessFactory</td><td>创建用于访问Access对象的工厂类</td><td>继承IFactory协议</td><td>创建用于访问用户的对象，创建用于访问部门的对象</td></tr></tbody></table><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>SQLServer操作用户表对象<br><figure class="codeblock codeblock--tabbed"><figcaption><span>SQLServerUser</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IUser.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SQLServerUser</span> : <span class="title">NSObject</span> &lt;<span class="title">IUser</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SQLServerUser.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SQLServerUser</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insert:(User *)user {</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在 SQL Server 中给 User 表增加一条记录"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (User *)getUser:(<span class="built_in">NSString</span> *)userId {</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在 SQL Server 中根据 userId 得到 User 表一条记录"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>Access操作部门表对象<br><figure class="codeblock codeblock--tabbed"><figcaption><span>AccessDepartment</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IDepartment.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AccessDepartment</span> : <span class="title">NSObject</span> &lt;<span class="title">IDepartment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AccessDepartment.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AccessDepartment</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insert:(Department *)department {</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在 Access 中给 Department 表增加一条记录"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (Department *)getDepartment:(<span class="built_in">NSString</span> *)departmentId {</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在 Access 中根据 departmentId 得到 Department 表一条记录"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>创建用于访问 SQL Server 对象的工厂类<br><figure class="codeblock codeblock--tabbed"><figcaption><span>example</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IFactory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用于访问 SQL Server 对象的工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SQLServerFactory</span> : <span class="title">NSObject</span> &lt;<span class="title">IFactory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SQLServerFactory.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SQLServerUser.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SQLServerDepartment.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SQLServerFactory</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;IUser&gt;)createUser {</span><br><span class="line">    <span class="keyword">return</span> [[SQLServerUser alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;IDepartment&gt;)createDepartment {</span><br><span class="line">    <span class="keyword">return</span> [[SQLServerDepartment alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>创建用于访问Access对象的工厂类<br><figure class="codeblock codeblock--tabbed"><figcaption><span>example</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IFactory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AccessFactory</span> : <span class="title">NSObject</span> &lt;<span class="title">IFactory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AccessFactory.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AccessUser.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AccessDepartment.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AccessFactory</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;IUser&gt;)createUser {</span><br><span class="line">    <span class="keyword">return</span> [[AccessUser alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;IDepartment&gt;)createDepartment {</span><br><span class="line">    <span class="keyword">return</span> [[AccessDepartment alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>客户端调用</p><figure class="highlight objectivec"><figcaption><span>AbstractFactoryTests</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//id&lt;IFactory&gt; factory = [[SQLServerFactory alloc] init];</span></div><div class="line">    <span class="keyword">id</span>&lt;IFactory&gt; factory = [[AccessFactory alloc] init];</div><div class="line">    <span class="keyword">id</span>&lt;IUser&gt; user = [factory createUser];</div><div class="line">    [user insert:[[User alloc]init]];</div><div class="line">    [user getUser:<span class="string">@""</span>];</div><div class="line">    <span class="keyword">id</span>&lt;IDepartment&gt; department = [factory createDepartment];</div><div class="line">    [department insert:[[Department alloc]init]];</div><div class="line">    [department getDepartment:<span class="string">@""</span>];</div></pre></td></tr></table></figure><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在以下情况下可以使用抽象工厂模式：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</li><li>抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li><li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</li><li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li><li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="工厂" scheme="http://blog.xiaodongwang.com/tags/%E5%B7%A5%E5%8E%82/"/>
    
      <category term="减耦合" scheme="http://blog.xiaodongwang.com/tags/%E5%87%8F%E8%80%A6%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之工厂方法（二）</title>
    <link href="http://blog.xiaodongwang.com/2017/05/17/1/"/>
    <id>http://blog.xiaodongwang.com/2017/05/17/1/</id>
    <published>2017-05-17T15:14:32.000Z</published>
    <updated>2018-05-10T03:10:45.578Z</updated>
    
    <content type="html"><![CDATA[<p>工厂方法（Factory）：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。<br><a id="more"></a><br>说人话：工厂方法模式将之前负责生成具体抽象子类的工厂类，抽象为工厂抽象类和工厂子类组成的一系列类。每创建一个抽象子类，就需要创建一个工厂子类，并且一一对应，由工厂子类去生成对应的抽象子类，由外界使用方来决定生成哪个工厂子类。这样在增加新的需求时，就不需要对工厂抽象类进行修改，而是对应新增的抽象子类创建对应的工厂子类即可。</p><h1 id="主要参与者"><a href="#主要参与者" class="headerlink" title="主要参与者"></a>主要参与者</h1><ul><li>抽象工厂角色：与应用程序无关，任何在模式中创建对象的工厂必须实现这个接口。</li><li>具体工厂角色：实现了抽象工厂接口的具体类，含有与引用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。</li><li>抽象产品角色：工厂方法所创建产品对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li><li>具体产品角色：这个角色实现了抽象产品角色所声名的接口。工厂方法所创建的每个具体产品对象都是某个具体产品角色的实例。</li></ul><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><!-- ![工厂方法](http://oxyk7k4jh.bkt.clouddn.com/2018-03-15-15211054413538.jpg) --><p><img src="http://oxyk7k4jh.bkt.clouddn.com/2018-03-15-15211059099502.jpg" alt="工厂方法"></p><p>我们讲过，既然这个工厂类与分支耦合，那么我就对它下手，根据依赖倒转原则，我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成一个工厂抽象接口和多个具体生成对象的工厂，于是我们要增加‘求M数的N次方’的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</li><li>这个系统有多于一个的产品族，而系统只消费其中某一产品族。</li><li>同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>抽象工厂类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ILeiFeng.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ILeiFengFactory</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>&lt;ILeiFeng&gt;)createLeiFeng;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><p>具体工厂类<br><figure class="codeblock codeblock--tabbed"><figcaption><span>UndergraduateFactory</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ILeiFengFactory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UndergraduateFactory</span> : <span class="title">NSObject</span>&lt;<span class="title">ILeiFengFactory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UndergraduateFactory.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Undergraduate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UndergraduateFactory</span></span></span><br><span class="line">- (<span class="keyword">id</span>&lt;ILeiFeng&gt;)createLeiFeng {</span><br><span class="line">    <span class="keyword">return</span> [[Undergraduate alloc] init];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure><br>抽象产品类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ILeiFeng</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="comment">// 扫地</span></div><div class="line">- (<span class="keyword">void</span>)sweep;</div><div class="line"><span class="comment">// 洗衣</span></div><div class="line">- (<span class="keyword">void</span>)wash;</div><div class="line"><span class="comment">// 买米</span></div><div class="line">- (<span class="keyword">void</span>)buyRice;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>具体产品类<br><figure class="codeblock codeblock--tabbed"><figcaption><span>Undergraduate</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ILeiFeng.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Undergraduate</span> : <span class="title">NSObject</span>&lt;<span class="title">ILeiFeng</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Undergraduate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Undergraduate</span></span></span><br><span class="line"><span class="comment">// 扫地</span></span><br><span class="line">- (<span class="keyword">void</span>)sweep{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"大学生扫地"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 洗衣</span></span><br><span class="line">- (<span class="keyword">void</span>)wash{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"大学生洗衣"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 买米</span></span><br><span class="line">- (<span class="keyword">void</span>)buyRice{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"大学生买米"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>测试用例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">实现</div><div class="line">- (<span class="keyword">void</span>)testFactoryMethod &#123;</div><div class="line">   <span class="comment">//id&lt;ILeiFengFactory&gt; iLeiFengFactory  = [[UndergraduateFactory alloc] init];</span></div><div class="line">    <span class="keyword">id</span>&lt;ILeiFengFactory&gt; iLeiFengFactory  = [[VolunteerFactory alloc] init];</div><div class="line">   <span class="keyword">id</span>&lt;ILeiFeng&gt; iLeiFeng = [iLeiFengFactory createLeiFeng];</div><div class="line">    [iLeiFeng sweep];</div><div class="line">    [iLeiFeng wash];</div><div class="line">    [iLeiFeng buyRice];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>工厂方法模式的的优点在于更大的灵活性，增加或删除某个产品都不会对其他地方造成影响，更佳符合开放封闭原则。<br>而且对抽象的使用更佳深入，将工厂类也抽象为了抽象工厂类和工厂子类，外界调用更加灵活，这也是对多态的一种体现。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>工厂方法模式的缺点也是非常显而易见的，工厂方法模式中新增一个抽象子类，意味着工厂子类要跟着成对增加(OC中要x4😭)，这样会造成生成过多的类，工厂方法模式的复杂度也会随之增加。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在了解了优缺点后，我总结了工厂方法模式的应用场景：</p><ul><li>当一个类不知道它所需要的对象的类时<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li><li>当一个类希望通过其子类来指定创建对象时<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展；</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂方法（Factory）：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="工厂" scheme="http://blog.xiaodongwang.com/tags/%E5%B7%A5%E5%8E%82/"/>
    
      <category term="减耦合" scheme="http://blog.xiaodongwang.com/tags/%E5%87%8F%E8%80%A6%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之简单工厂模式（一）</title>
    <link href="http://blog.xiaodongwang.com/2017/05/12/19912/"/>
    <id>http://blog.xiaodongwang.com/2017/05/12/19912/</id>
    <published>2017-05-12T15:14:32.000Z</published>
    <updated>2018-05-10T03:10:01.515Z</updated>
    
    <content type="html"><![CDATA[<p>常用工厂模式有简单工厂模式、工厂方法模式、抽象工厂模式<br><a id="more"></a></p><h1 id="什么是简单工厂模式？"><a href="#什么是简单工厂模式？" class="headerlink" title="什么是简单工厂模式？"></a>什么是简单工厂模式？</h1><p>简单工厂模式中定义一个抽象类，抽象类中声明公共的特征及属性，抽象子类继承自抽象类，去实现具体的操作。工厂类根据外界需求，在工厂类中创建对应的抽象子类实例并传给外界，而对象的创建是由外界决定的。外界只需要知道抽象子类对应的参数即可，而不需要知道抽象子类的创建过程，在外界使用时甚至不用引入抽象子类。</p><p>简单工厂模式将操作对象的创建，和关于操作对象相关的业务逻辑分离开，降低操作对象的耦合度。由于工厂类只是为外界创建对象，所以并不需要实例化工厂类对象，只需要为外界提供类方法即可。外界需要什么类型的抽象子类，只需要传递对应的参数即可。</p><p>简单工厂模式主要包含三部分：</p><ul><li>工厂类：根据外界的需求，决定创建并返回哪个具体的抽象子类。</li><li>抽象类：定义抽象子类所需的属性和方法，子类通过继承自抽象类获得这些方法。</li><li>抽象子类：继承自抽象类，是具体操作的实现者。 </li></ul><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>简单工厂模式主要适用于抽象子类的业务逻辑相同，但具体实现不同的情况。不同的操作子类执行同样的方法，最后的结果却是不同的，这也是多态的一种表现方式。</p><p>这里用一个简单的加减乘除的基础运算例子来说明一下，下面的UML类图和代码都会依据这个场景来实现。假设现在需要实现一个简单的加减乘除运算，这些运算具体操作都是类似的，都有两个被操作的值，只是运算符不同，这种情况就适合用简单工厂模式。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p><img src="http://oxyk7k4jh.bkt.clouddn.com/2018-03-13-SimpleFactory.jpg" alt="SimpleFactory"></p><p>从上面图中我们可以看出，图中定义了一个运算抽象类，所有的运算操作类继承自这个运算抽象类。运算抽象类有两个参与运算的属性，通过调用getResult方法来获取这两个值最后运算的结果，调用方式都一样，只是最后的结果不同。抽象类并不参与运算，运算的结果通过运算操作类重载getResult方法去实现。<br>上图中还定义了一个简单工厂类，这个简单工厂类就是用于实现运算操作类实例化的逻辑，通过外界传进来的type参数，并将实例完成的运算操作类返回。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>首先定义抽象类，抽象类中将会包含参与运算的抽象子类的属性和行为(方法)。</p><figure class="codeblock codeblock--tabbed"><figcaption><span>Operation(抽象运算类)</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, OperationType) {</span><br><span class="line">    OperationTypeAdd,<span class="comment">//加法</span></span><br><span class="line">    OperationTypeSub,<span class="comment">//减法</span></span><br><span class="line">    OperationTypeMul,<span class="comment">//乘法</span></span><br><span class="line">    OperationTypeDiv<span class="comment">//除法</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象运算类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Operation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作数A</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> numberA;</span><br><span class="line"><span class="comment">//操作数B</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> numberB;</span><br><span class="line"><span class="comment">//获得运算结果</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)getResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Operation</span></span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)getResult {</span><br><span class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>定义抽象类之后，需要创建负责具体运算的抽象子类，也就是操作类，简单的定义了一下，以加法类为例，代码太多就不全贴出来了。</p><figure class="codeblock codeblock--tabbed"><figcaption><span>OperationAdd(加法类)</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationAdd</span> : <span class="title">Operation</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"OperationAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationAdd</span></span></span><br><span class="line">-(<span class="built_in">CGFloat</span>)getResult {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.numberA + <span class="keyword">self</span>.numberB;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>现在具体参与运算的类都已经定义完成，就需要定义工厂类了。工厂类的职责就是根据外界需要，创建对应的抽象子类实例并返回给外界。</p><figure class="codeblock codeblock--tabbed"><figcaption><span>OperationFactory(简单的工厂类)</span><ul class="tabs"><li class="tab active">objectivec</li><li class="tab">objectivec</li></ul></figcaption><div class="tabs-content"><figure class="highlight objectivec" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationFactory</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 简单的工厂方法用于创建运算实例</span><br><span class="line"></span><br><span class="line"> @param operationType 运算类型</span><br><span class="line"> @return 运算实例</span><br><span class="line"> */</span></span><br><span class="line">+ (Operation *)createOperation:(OperationType) operationType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight objectivec" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"OperationFactory.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OperationAdd.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OperationSub.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OperationMul.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OperationDiv.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationFactory</span></span></span><br><span class="line"><span class="comment">//一般工厂方法返回业务实例</span></span><br><span class="line">+ (Operation *)createOperation:(OperationType) operationType {</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (operationType) {</span><br><span class="line">   <span class="keyword">case</span> OperationTypeAdd:</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">return</span> [[OperationAdd alloc] init];</span><br><span class="line">   }</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> OperationTypeSub:</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">return</span> [[OperationSub alloc] init];</span><br><span class="line">   }</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> OperationTypeMul:</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">return</span> [[OperationMul alloc] init];</span><br><span class="line">   }</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> OperationTypeDiv:</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">return</span> [[OperationDiv alloc] init];</span><br><span class="line">   }</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>上面我们就将工厂设计模式的定义都完成了，现在需要的就是外界直接拿来使用了。上面工厂类直接定义的类方法，因为外界获取某个具体的抽象子类时，并没有必要将工厂类实例化，工厂类只是完成一个功能。</p><figure class="highlight objectivec"><figcaption><span>SimpleFactoryTests</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testSimpleFactory &#123;</div><div class="line">    </div><div class="line">    Operation *operation = [OperationFactory createOperation:OperationTypeAdd];</div><div class="line">    operation.numberA = <span class="number">100</span>;</div><div class="line">    operation.numberB = <span class="number">25</span>;</div><div class="line">    <span class="built_in">XCTAssertTrue</span>([operation getResult] == <span class="number">125</span>);</div><div class="line">    </div><div class="line">    operation = [OperationFactory createOperation:OperationTypeSub];</div><div class="line">    operation.numberA = <span class="number">100</span>;</div><div class="line">    operation.numberB = <span class="number">75</span>;</div><div class="line">    <span class="built_in">XCTAssertTrue</span>([operation getResult] == <span class="number">25</span>);</div><div class="line">    </div><div class="line">    operation = [OperationFactory createOperation:OperationTypeMul];</div><div class="line">    operation.numberA = <span class="number">100</span>;</div><div class="line">    operation.numberB = <span class="number">25</span>;</div><div class="line">    <span class="built_in">XCTAssertTrue</span>([operation getResult] == <span class="number">2500</span>);</div><div class="line">    </div><div class="line">    operation = [OperationFactory createOperation:OperationTypeDiv];</div><div class="line">    operation.numberA = <span class="number">100</span>;</div><div class="line">    operation.numberB = <span class="number">25</span>;</div><div class="line">    <span class="built_in">XCTAssertTrue</span>([operation getResult] == <span class="number">4</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//operation = [[Operation alloc] init];</span></div><div class="line">    <span class="comment">//XCTAssertTrue([operation getResult] == 4);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到目前为止简单工厂模式的代码就写完了，可以看到外界想进行什么类型的运算，只需要将传入的运算类型参数改一下即可，工厂类就会实例化其他的抽象子类进行运算。但是这种工厂类的设计，有一个很大的问题，就在于每次增加或删除某个算法时，都需要对工厂类进行修改，这是不符合开放封闭原则的。对于这个问题，我们以后将会通过反射机制来进行处理，这里就不做说明了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用工厂模式有简单工厂模式、工厂方法模式、抽象工厂模式&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="工厂" scheme="http://blog.xiaodongwang.com/tags/%E5%B7%A5%E5%8E%82/"/>
    
      <category term="减耦合" scheme="http://blog.xiaodongwang.com/tags/%E5%87%8F%E8%80%A6%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之代理模式（一）</title>
    <link href="http://blog.xiaodongwang.com/2017/04/16/63575/"/>
    <id>http://blog.xiaodongwang.com/2017/04/16/63575/</id>
    <published>2017-04-16T15:14:32.000Z</published>
    <updated>2018-05-10T03:09:25.157Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中经常会用到代理的设计模式,这是iOS中一种消息传递的方式,也可以通过这种方式传递一些参数。在项目中,刚开始我是用一些代理来传递参数的,但是慢慢觉得代理的代码比较block多,所以就更多的使用了block。前几天突然想到了代理的设计模式,回头又详细看了下代理的相关文档，在此把个人看法记录下来。<br><a id="more"></a><br><!-- TOC --></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>苹果官方文档对代理设计模式作了精练的描述：</p><blockquote><p>“代理设计模式是一种简单却又强大的设计模式。在这个模式中，一个对象可以与另一对象进行协同交互，或者直接代表另一对象行动。委托对象（the delegating object）中会保有一个指向代理对象（the delegate）的引用，并在合适的时机向他发送消息，通知他委托对象即将或已经处理完毕的事件。代理对象收到通知后，可以通过更新自己或其他对象的展现形式（UI界面）或状态来进行响应，在某些情况下也可以返回一个值给委托对象以影响其对即将发生的事件的处理。代理设计模式的主要价值在于可以让人在一个主对象中轻松定制各种对象的行为。”</p></blockquote><h1 id="protocol–协议"><a href="#protocol–协议" class="headerlink" title="protocol–协议"></a>protocol–协议</h1><p>协议是公共的定义，如果只是某个类使用，我们常做的就是写在某个类中。如果是多个类都是用同一个协议，建议创建一个Protocol文件，在这个文件中定义协议。遵循的协议可以被继承，例如我们常用的UITableView，由于继承自UIScrollView的缘故，所以也将UIScrollViewDelegate继承了过来，我们可以通过代理方法获取UITableView偏移量等状态参数。</p><p>协议可以继承其他协议,并且可以继承多个协议,在iOS中对象是不支持多继承的,但是协议可以.</p><h1 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h1><p>代理对象在很多情况下其实是可以复用的,可以创建多个代理对象为对个委托方服务.</p><h1 id="怎样写一个代理设计模式"><a href="#怎样写一个代理设计模式" class="headerlink" title="怎样写一个代理设计模式"></a>怎样写一个代理设计模式</h1><ol><li>你要明确你的协议名称，一般来讲名称都是:控件类名 + Delegate</li><li>代理方法中一般都是声明为@optional（程序默认情况下是@required)</li><li>代理方法名一般以控件开头</li><li>代理方法至少有一个参数</li></ol><h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h1><p>假如你喜欢一个女生，你想送礼物给她，但是你又不认识人家，这时候恰巧你的同学A认识这个女同学，这时候你（委托也叫代理对象）请求你的同学A（代理也叫委托对象）代你送礼物给这个女生。<br>那这个送一些什么礼物就是你和你同学A协商的<code>协议</code>。文末有我在GitHub上的Demo。感兴趣的可以去看看。</p><h1 id="代理内存管理"><a href="#代理内存管理" class="headerlink" title="代理内存管理"></a>代理内存管理</h1><p>delegate的属性都是用weak,因为strong类型的指针会造成强引用,必定会影响一个对象的生命周期,这也就会形成循环引用.</p><h1 id="代理和block的选择"><a href="#代理和block的选择" class="headerlink" title="代理和block的选择"></a>代理和block的选择</h1><p>•    从设计模式的角度来说，代理更佳面向过程，而block更佳面向结果。<br>•    从性能上来说，block的性能消耗要略大于delegate，因为block会涉及到栈区向堆区拷贝等操作，时间和空间上的消耗都大于代理。而代理只是定义了一个方法列表，在遵守协议对象的objc_protocol_list中添加一个节点，在运行时向遵守协议的对象发送消息即可。<br>•    有多个相关方法。假如每个方法都设置一个 block, 这样会更麻烦。而 delegate 让多个方法分成一组，只需要设置一次，就可以多次回调。当多于 3 个方法时就应该优先采用 delegate。<br>•    为了避免循环引用，也可以使用 delegate。</p><h1 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h1><p>•    具有良好的扩展性。委托的业务逻辑可能会随时改变，当有新增功能，只需要在协议中增加方法就能不影响原有功能的情况下增加新功能<br>•    有利于代码的封装。如果一个类，实现了某个协议，那么这个协议中的属性或方法就不必公有化，就可以被定义协议的类调用。这样可以减少一个类暴露给外部的方法<br>•    有利于程序的结构化与层次化。一个协议往往是解决某一个问题，对于一个其他的不过却类似的问题，我们只用再次实现协议即可，避免了自己再次构思一组方法，提高代码的复用性</p><p>感兴趣可以看我的github上的<a href="https://github.com/wxd19891212/TrainingDesignPatterns/tree/master/TrainingDesignPatterns/Proxy" target="_blank" rel="external">代理模式demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中经常会用到代理的设计模式,这是iOS中一种消息传递的方式,也可以通过这种方式传递一些参数。在项目中,刚开始我是用一些代理来传递参数的,但是慢慢觉得代理的代码比较block多,所以就更多的使用了block。前几天突然想到了代理的设计模式,回头又详细看了下代理的相关文档，在此把个人看法记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="减耦合" scheme="http://blog.xiaodongwang.com/tags/%E5%87%8F%E8%80%A6%E5%90%88/"/>
    
      <category term="代理" scheme="http://blog.xiaodongwang.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式</title>
    <link href="http://blog.xiaodongwang.com/2017/04/07/37104/"/>
    <id>http://blog.xiaodongwang.com/2017/04/07/37104/</id>
    <published>2017-04-07T15:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.932Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是软件设计中常见问题的可重用解决方案。他们的模板旨在帮助您编写易于理解和重用的代码。他们还帮助您创建松散耦合的代码，以便您可以更改或替换代码中的组件，而不会太麻烦。<a id="more"></a></p><p>如果你是设计模式的新手，那么我对你有好消息！首先，您已经使用了大量的iOS设计模式，这要归功于Cocoa的构建方式以及鼓励您使用的最佳实践。其次，本教程将带您了解Cocoa常用的所有主要（而不是主要）iOS设计模式。<br>本教程分为几个部分，每个设计模式一个部分。在每个部分中，您将阅读以下内容的解释：</p><ul><li>设计模式是什么。</li><li>为什么你应该使用它。</li><li>如何使用它，并在适当情况下，使用该模式时要注意的常见陷阱。</li></ul><p>设计模式的基本原则非常重要，只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了：</p><ul><li>单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。</li><li>开放-封闭原则（OCP），是说软件实体（类、模块、函数等等）应该可以拓展，但是不可修改。</li><li>依赖倒转原则（DIP），A. 高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。</li><li>里氏代换原则（LSP），子类型必须能够替换掉它们的父类型。</li><li>迪米特法则（LoD），如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</li><li>合成/聚合复用原则（CARP），尽量使用合成/聚合，尽量不要使用类继承。<blockquote><p>注：SRP-Single Responsibility Principle，OCP-Open-Closed Principle，DIP-Dependency Inversion Principle，LSP-Liskov Subsitution Principle，LoD-Law of Demeter，CARP-Composition/Aggregation Principle。</p></blockquote></li></ul><h1 id="常用的-23-种设计模式"><a href="#常用的-23-种设计模式" class="headerlink" title="常用的 23 种设计模式"></a>常用的 23 种设计模式</h1><p>不管是 .NET 中的 C# 语言，还是 Java、VB.NET、C++ 或 Objective-C 语言，面向对象语言在设计模式的层面上都是相通的，只不过在设计模式的具体实现上语法稍有差异罢了：</p><ol><li>策略模式（Strategy），它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</li><li>装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</li><li>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</li><li>工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li><li>原型模式（Prototype），用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li><li>模板方法模式（Template Method），定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li>建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li>观察者模式（Observer），定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li><li>抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li><li>状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</li><li>适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>备忘录模式（Memento），在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</li><li>组合模式（Composite），将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</li><li>迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</li><li>单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>桥接模式（Bridge），将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li>命令模式（Command），将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</li><li>职责链模式（Chain of Responsibility），使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</li><li>中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li>享元模式（Flyweight），运用共享技术有效地支持大量细粒度的对象。</li><li>解释器模式（Interpreter），给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li><li>访问者模式（Visitor），表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<h1 id="设计模式三种类型"><a href="#设计模式三种类型" class="headerlink" title="设计模式三种类型"></a>设计模式三种类型</h1></li></ol><p>创建型：一、Abstract Factory，抽象工厂<br>         二、Builder，建造模式，<br>         三、Factory Method，工厂方法<br>         四、Prototype，原型模式<br>         五、Singleton，单例模式</p><p>结构型：一、Adapter,适配器模式<br>         二、Bridge，桥接模式<br>         三、Composite，组合模式<br>         四、Decrator，装饰模式<br>         五、Facade，外观模式<br>         六、Proxy，代理模式<br>         七、Flyweight，享元模式</p><p>行为型：一、Chain of Responsibility，职责链模式<br>         二、Command，命令模式<br>         三、Interpreter，解释器模式<br>         四、Iterator，迭代器模式<br>         五、Mediator，中介者模式<br>         六、Memento，备忘录模式<br>         七、Observer，观察者模式<br>         八、State，状态模式<br>         九、Strategy，策略模式<br>         十、Template Method，模板方法<br>         十一、Visitor，访问者模式<br><img src="https://upload-images.jianshu.io/upload_images/1822069-3fa8222188bd376d.png" alt="23种设计模式分类"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式是软件设计中常见问题的可重用解决方案。他们的模板旨在帮助您编写易于理解和重用的代码。他们还帮助您创建松散耦合的代码，以便您可以更改或替换代码中的组件，而不会太麻烦。
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iOS/"/>
    
    
      <category term="设计模式" scheme="http://blog.xiaodongwang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS中block的用法和理解</title>
    <link href="http://blog.xiaodongwang.com/2017/01/25/30423/"/>
    <id>http://blog.xiaodongwang.com/2017/01/25/30423/</id>
    <published>2017-01-25T15:14:32.000Z</published>
    <updated>2018-05-10T03:08:07.908Z</updated>
    
    <content type="html"><![CDATA[<p>block是一个OC对象, 它的功能是保存代码片段, 预先准备好代码, 并在需要的时候执行.<br><a id="more"></a><br><!-- TOC --></p><h1 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h1><p>Block表达式语法：<br>^ 返回值类型 (参数列表) {表达式}</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">^ <span class="keyword">int</span> (<span class="keyword">int</span> a) &#123;</div><div class="line">      <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"最简模式Block"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h1><p>声明Block类型变量语法：<br>返回值类型 (^变量名)(参数列表) = Block表达式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^myBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a,<span class="keyword">int</span> b) &#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">int</span> c = myBlock(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"c=%d"</span>,c);</div></pre></td></tr></table></figure><p>当Block类型变量作为函数的参数时，写作：<br>返回值类型 (^)(参数列表) block变量名<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> testParmWithBlock:^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">&#125;];</div><div class="line">- (<span class="keyword">void</span>)testParmWithBlock:(<span class="keyword">int</span>(^)(<span class="keyword">int</span> a,<span class="keyword">int</span> b))block &#123;</div><div class="line">    block(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[block <span class="keyword">class</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>借助typedef可简写：<br>typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^TypedefBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>);</div><div class="line">[<span class="keyword">self</span> testParmWithTypedefBlock:^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">&#125;];</div><div class="line">- (<span class="keyword">void</span>)testParmWithTypedefBlock: (TypedefBlock)myTypedefBlock&#123;</div><div class="line">    myTypedefBlock(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>截获自动变量值<br>Block表达式可截获所使用的自动变量的值。<br>截获：保存自动变量的瞬间值。<br>因为是“瞬间值”，所以声明Block之后，即便在Block外修改自动变量的值，也不会对Block内截获的自动变量值产生影响。<br>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</div><div class="line"><span class="keyword">void</span>(^myAutomaticVariable)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"In block, i = %d"</span>, i);</div><div class="line">&#125;;</div><div class="line">i = <span class="number">20</span>;<span class="comment">//Block外修改变量i，也不影响Block内的自动变量</span></div><div class="line">myAutomaticVariable();<span class="comment">//i修改为20后才执行，打印: In block, i = 10</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"i = %d"</span>, i);<span class="comment">//打印：i = 20</span></div></pre></td></tr></table></figure><h1 id="block说明符号"><a href="#block说明符号" class="headerlink" title="__block说明符号"></a>__block说明符号</h1><p>自动变量截获的值为Block声明时刻的瞬间值，保存后就不能改写该值，如需对自动变量进行重新赋值，需要在变量声明前附加<code>__block</code>说明符，这时该变量称为<code>__block</code>变量。</p><p>自动变量值为一个对象情况<br>当自动变量为一个类的对象，且没有使用<code>__block</code>修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。<br>如果该对象是个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *varMuArr = [@[<span class="string">@"1"</span>,<span class="string">@"2"</span>] mutableCopy];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"varMuArr Count:%ld"</span>, varMuArr.count);<span class="comment">//打印varMuArr Count:2</span></div><div class="line"><span class="keyword">void</span> (^muArrBlock)(<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> *str) &#123;</div><div class="line">   [varMuArr addObject:str]; <span class="comment">//可以修改属性</span></div><div class="line">   <span class="comment">//varMuArr = [@[@"5"] mutableCopy]; 不能赋值 Variable is not assignable (missing __block type specifier)</span></div><div class="line">&#125;;</div><div class="line">muArrBlock(<span class="string">@"3"</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"varMuArr Count:%ld"</span>, varMuArr.count);<span class="comment">//打印varMuArr Count:3</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[muArrBlock <span class="keyword">class</span>]);<span class="comment">//打印：__NSMallocBlock__</span></div></pre></td></tr></table></figure><h1 id="Block实现原理"><a href="#Block实现原理" class="headerlink" title="Block实现原理"></a>Block实现原理</h1><p>使用Clang<br>Block实际上是作为极普通的C语言源码来处理的：含有Block语法的源码首先被转换成C语言编译器能处理的源码，再作为普通的C源代码进行编译。<br>使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：<br><code>clang -rewrite-objc 源码文件名</code></p><h2 id="Block结构"><a href="#Block结构" class="headerlink" title="Block结构"></a>Block结构</h2><p>使用Block的时候，编译器对Block语法进行了怎样的转换？<br>如上所示的最简单的Block使用代码，经clang转换后，可得到以下几个部分（有代码删减和注释添加）：<br><code>__ViewController__viewDidLoad_block_impl_6</code>即为viewDidLoad()函数栈上的Block结构体<br>将上面的代码段clang，发现Block的结构体<code>__ViewController__viewDidLoad_block_impl_6</code>结构如下所示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_6 &#123;</div><div class="line"><span class="keyword">struct</span> __block_impl impl;</div><div class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_6* Desc;</div><div class="line"><span class="built_in">NSMutableArray</span> *varMuArr;</div><div class="line">__ViewController__viewDidLoad_block_impl_6(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_6 *desc, <span class="built_in">NSMutableArray</span> *_varMuArr, <span class="keyword">int</span> flags=<span class="number">0</span>) : varMuArr(_varMuArr) &#123;</div><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">impl.Flags = flags;</div><div class="line">impl.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>Block有三种类（即<code>__block_impl</code>的isa指针指向的值，isa说明参考《Objective-C isa 指针 与 runtime 机制》），根据Block对象创建时所处数据区不同而进行区别：</p><p><code>_NSConcreteStackBlock</code>：在栈上创建的Block对象<br><code>_NSConcreteMallocBlock</code>：在堆上创建的Block对象   出了作用域后引用会复制到堆区<br><code>_NSConcreteGlobalBlock</code>：全局数据区的Block对象    不引用外部变量<br>观察上节代码中<code>__ViewController__viewDidLoad_block_impl_6</code>结构体（viewDidLoad栈上Block的结构体）的构造函数可以看到，栈上的变量_varMuArr以参数的形式传入到了这个构造函数中，此处即为变量的自动截获。变量被保存在Block的结构体实例中。</p><p>所以在muArrBlock()执行之前，栈上简单数据类型的_varMuArr无论发生什么变化，都不会影响到Block以参数形式传入而捕获的值。但这个变量是指向对象的指针时，是可以修改这个对象的属性的，只是不能为变量重新赋值。</p><h1 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h1><p>上文已提到，根据Block创建的位置不同，Block有三种类型，创建的Block对象分别会存储到栈、堆、全局数据区域。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^globalBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Global Block"</span>);</div><div class="line">&#125;;</div><div class="line">globalBlock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[globalBlock <span class="keyword">class</span>]);<span class="comment">//打印：__NSGlobalBlock__</span></div></pre></td></tr></table></figure><p>像上面代码块中的全局globalBlock自然是存储在全局数据区，但注意在函数栈上创建的blk，如果没有截获自动变量，Block的结构实例还是会被设置在程序的全局数据区，而非栈上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> s = <span class="number">1</span>;</div><div class="line"><span class="keyword">void</span> (^stackBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"s=%d"</span>,s);</div><div class="line">&#125;;</div><div class="line">stackBlock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[stackBlock <span class="keyword">class</span>]);<span class="comment">//打印：__NSMallocBlock__</span></div></pre></td></tr></table></figure><p>可以看到截获了自动变量的Block打印的类是<code>__NSGlobalBlock__</code>，表示存储在全局数据区。<br>但为什么捕获自动变量的Block打印的类却是设置在堆上的<code>__NSMallocBlock__</code>，而非栈上的<code>__NSStackBlock__</code>?这个问题稍后解释。</p><h1 id="Block复制"><a href="#Block复制" class="headerlink" title="Block复制"></a>Block复制</h1><p>配置在栈上的Block，如果其所属的栈作用域结束，该Block就会被废弃，对于超出Block作用域仍需使用Block的情况，Block提供了将Block从栈上复制到堆上的方法来解决这种问题，即便Block栈作用域已结束，但被拷贝到堆上的Block还可以继续存在。<br>复制到堆上的Block，将<code>_NSConcreteMallocBlock</code>类对象写入Block结构体实例的成员变量isa：<br><code>impl.isa = &amp;_NSConcreteMallocBlock;</code></p><p>在ARC有效时，大多数情况下编译器会进行判断，自动生成将Block从栈上复制到堆上的代码(或者直接在堆上创建Block对象)，以下几种情况栈上的Block会自动复制到堆上：</p><p>调用Block的copy方法<br>将Block作为函数返回值时（MRC时此条无效，需手动调用copy）  这个有问题<br>将Block赋值给<code>__strong</code>修改的变量时（MRC时此条无效）<br>向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时</p><p>其它时候向方法的参数中传递Block时，需要手动调用copy方法复制Block。<br>上一节的栈上截获了自动变量i的Block之所以在栈上创建，却是<code>_NSMallocBlock__</code>类，就是因为这个Block对象赋值给了<code>__strong</code>修饰的变量**captureBlk（_strong是ARC下对象的默认修饰符）。<br>因为上面四条规则，在ARC下其实很少见到<code>_NSConcreteStackBlock</code>类的Block，大多数情况编译器都保证了Block是在堆上创建的，如下代码所示，仅最后一行代码直接使用一个不赋值给变量的Block，它的类才是<code>__NSStackBlock__</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^TypedefBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>);</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(^TypedefStringBlock)(<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *);</div><div class="line"></div><div class="line"><span class="keyword">int</span> m=<span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</div><div class="line">TypedefBlock rblock = [<span class="keyword">self</span> testReturnBlock];</div><div class="line"><span class="keyword">int</span> rVar = rblock(m,n);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[rblock <span class="keyword">class</span>]);<span class="comment">//打印：__NSGlobalBlock__</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"rVar=%d"</span>,rVar);</div><div class="line">    </div><div class="line">TypedefStringBlock strBlock = [<span class="keyword">self</span> testReturnStrBlock];</div><div class="line"><span class="built_in">NSString</span> *strVar = strBlock(<span class="string">@"String"</span>,<span class="string">@"Block"</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[strBlock <span class="keyword">class</span>]);<span class="comment">//打印：__NSGlobalBlock__</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"str=%@"</span>,strVar);</div><div class="line">    </div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Stack Block:%@"</span>, [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Stack Block:%d"</span>,count);&#125; <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">- (TypedefBlock)testReturnBlock &#123;</div><div class="line">    <span class="keyword">int</span> (^returnBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//globalBlock();</span></div><div class="line">    <span class="keyword">return</span> returnBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (TypedefStringBlock)testReturnStrBlock &#123;</div><div class="line">    <span class="built_in">NSString</span> * (^returnBlock)(<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> * a,<span class="built_in">NSString</span> * b)&#123;</div><div class="line">        <span class="keyword">return</span> [a stringByAppendingString:b];</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//globalBlock();</span></div><div class="line">    <span class="keyword">return</span> returnBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="使用-block发生了什么"><a href="#使用-block发生了什么" class="headerlink" title="使用__block发生了什么"></a>使用__block发生了什么</h1><p>Block捕获的自动变量添加<code>__block</code>说明符，就可在Block内读和写该变量，也可以在原来的栈上读写该变量。<br>自动变量的截获保证了栈上的自动变量被销毁后，Block内仍可使用该变量。<br><code>__block</code>保证了栈上和Block内（通常在堆上）可以访问和修改“同一个变量”，<code>__block</code>是如何实现这一功能的？<br><code>__block</code>发挥作用的原理：将栈上用<code>__block</code>修饰的自动变量封装成一个结构体，让其在堆上创建，以方便从栈上或堆上访问和修改同一份数据。</p><p>现在对刚才的代码段，加上<code>__block</code>说明符，并在block内外读写变量ivar。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> ivar=<span class="number">10</span>;</div><div class="line"><span class="keyword">void</span>(^myChangeBlockVar)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">   ivar = <span class="number">20</span>;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"In block, ivar = %d"</span>, ivar);<span class="comment">//打印：In block, ivar = 20</span></div><div class="line">&#125;;</div><div class="line">ivar++;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Out Block: ivar = %d"</span>, ivar);<span class="comment">//Out Block: ivar = 11</span></div><div class="line">myChangeBlockVar();</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_10 &#123;</div><div class="line"><span class="keyword">struct</span> __block_impl impl;</div><div class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_10* Desc;</div><div class="line">__Block_byref_ivar_0 *ivar; <span class="comment">// by ref</span></div><div class="line">__ViewController__viewDidLoad_block_impl_10(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_10 *desc, __Block_byref_ivar_0 *_ivar, <span class="keyword">int</span> flags=<span class="number">0</span>) : ivar(_ivar-&gt;__forwarding) &#123;</div><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">impl.Flags = flags;</div><div class="line">impl.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最大的变化就是ivar变量不再是int类型了，ivar变成了一个指向<code>__Block_byref_ivar_0</code>结构体的指针，<code>__Block_byref_ivar_0</code>结构如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __Block_byref_ivar_0 &#123;</div><div class="line"><span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_ivar_0 *__forwarding;</div><div class="line"><span class="keyword">int</span> __flags;</div><div class="line"><span class="keyword">int</span> __size;</div><div class="line"><span class="keyword">int</span> ivar;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>它保存了int ivar变量，还有一个指向<code>__Block_byref_ivar_0</code>实例的指针<code>__forwarding</code>，通过下面两段代码<code>__forwarding</code>指针的用法可以知道，该指针其实指向的是对象自身：</p><h1 id="Block的执行函数"><a href="#Block的执行函数" class="headerlink" title="Block的执行函数"></a>Block的执行函数</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_func_10(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_10 *__cself) &#123;</div><div class="line">__Block_byref_ivar_0 *ivar = __cself-&gt;ivar; <span class="comment">// bound by ref</span></div><div class="line">     </div><div class="line">(ivar-&gt;__forwarding-&gt;ivar) = <span class="number">20</span>; <span class="comment">//对应count = 20;</span></div><div class="line"><span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_mb_gqftsnzd5694x3wr5glk3sfm0000gn_T_ViewController_609dca_mi_22, (ivar-&gt;__forwarding-&gt;ivar));</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_ivar_0 ivar = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_ivar_0 *)&amp;ivar, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_ivar_0), <span class="number">10</span>&#125;;</div><div class="line">     </div><div class="line"><span class="keyword">void</span>(*myChangeBlockVar)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__ViewController__viewDidLoad_block_impl_10((<span class="keyword">void</span> *)__ViewController__viewDidLoad_block_func_10, &amp;__ViewController__viewDidLoad_block_desc_10_DATA, (__Block_byref_ivar_0 *)&amp;ivar, <span class="number">570425344</span>));</div><div class="line">     </div><div class="line">(ivar.__forwarding-&gt;ivar)++; <span class="comment">//对应count ++;</span></div><div class="line">     </div><div class="line"><span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_mb_gqftsnzd5694x3wr5glk3sfm0000gn_T_ViewController_609dca_mi_23, (ivar.__forwarding-&gt;ivar));</div><div class="line">     </div><div class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myChangeBlockVar)-&gt;FuncPtr)((__block_impl *)myChangeBlockVar);</div></pre></td></tr></table></figure><p>为什么要通过<code>__forwarding</code>指针完成对ivar变量的读写修改？<br>为了保证无论是在栈上还是在堆上，都能通过都<code>__forwarding</code>指针找到在堆上创建的ivar这个<code>__ViewController__viewDidLoad_block_func_10</code>结构体，以完成对ivar-&gt;ivar（第一个ivar是<code>__ViewController__viewDidLoad_block_func_10</code>对象，第二个ivar是int类型变量）的访问和修改。</p><h1 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h1><p>Block的循环引用原理和解决方法大家都比较熟悉，此处将结合上文的介绍，介绍一种不常用的解决Block循环引用的方法和一种借助Block参数解决该问题的方法。<br>Block循环引用原因：一个对象A有Block类型的属性，从而持有这个Block，如果Block的代码块中使用到这个对象A，或者仅仅是用用到A对象的属性，会使Block也持有A对象，导致两者互相持有，不能在作用域结束后正常释放。<br>解决原理：对象A照常持有Block，但Block不能强引用持有对象A以打破循环。<br>解决方法：<br>方法一： 对Block内要使用的对象A使用<code>__weak</code>进行修饰，Block对对象A弱引用打破循环。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">__block ViewController* weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">self</span>.blk = ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"In Block : %@"</span>,weakSelf);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">使用__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)</div><div class="line">     </div><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">self</span>.blk = ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"In Block : %@"</span>,weakSelf);</div><div class="line">&#125;;</div><div class="line">     </div><div class="line">使用宏</div><div class="line"><span class="meta">#define Weakify(x) typeof(x) __weak weak##x = x;</span></div><div class="line"><span class="meta">#define Strongfiy(x)  typeof(x) __strong x = weak##x;</span></div><div class="line">@Weakify(<span class="keyword">self</span>);</div><div class="line"><span class="keyword">self</span>.blk = ^&#123;</div><div class="line">@Strongfiy(<span class="keyword">self</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"In Block : %@"</span>,<span class="keyword">self</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>方法二：对Block内要使用的对象A使用<code>__block</code>进行修饰，并在代码块内，使用完<code>__block</code>变量后将其设为nil，并且该block必须至少执行一次。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__block XXController *blkSelf = <span class="keyword">self</span>;</div><div class="line">     <span class="keyword">self</span>.blk = ^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"In Block : %@"</span>,blkSelf);</div><div class="line">     blkSelf = <span class="literal">nil</span>;<span class="comment">//不能省略</span></div><div class="line">     &#125;;</div></pre></td></tr></table></figure><p>在block代码块内，使用完使用完<code>__block</code>变量后将其设为nil，并且该block必须至少执行一次后，不存在内存泄露，因为此时：<br>XXController对象持有Block对象blk<br>blk对象持有<code>__block</code>变量blkSelf(类型为编译器创建的结构体)<br><code>__block</code>变量blkSelf在执行blk()之后被设置为nil（<code>__block</code>变量结构体的<code>__forwarding</code>指针指向了nil），不再持有XXController对象，打破循环</p><p>第二种使用<code>__block</code>打破循环的方法，优点是：<br>可通过<code>__block</code>变量动态控制持有XXController对象的时间，运行时决定是否将nil或其他变量赋值给<code>__block</code>变量<br>不能使用<code>__weak</code>的系统中，使用<code>__unsafe_unretained</code>来替代<code>__weak</code>打破循环可能有野指针问题，使用<code>__block</code>则可避免该问题</p><p>其缺点也明显：<br>必须手动保证<code>__block</code>变量最后设置为nil<br>block必须执行一次，否则<code>__block</code>不为nil循环应用仍存在<br>self.blk();//该block必须执行一次，否则还是内存泄露<br>因此，还是避免使用第二种不常用方式，直接使用<code>__weak</code>打破Block循环引用。</p><p>方法三：将在Block内要使用到的对象（一般为self对象），以Block参数的形式传入，Block就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄露。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.blk = ^(<span class="built_in">UIViewController</span> *vc) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Use Property:%@"</span>, vc.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">self</span>.blk(<span class="keyword">self</span>);</div></pre></td></tr></table></figure><p>优点：<br>简化了两行代码，更优雅<br>更明确的API设计：告诉API使用者，该方法的Block直接使用传进来的参数对象，不会造成循环引用，不用调用者再使用weak避免循环</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;block是一个OC对象, 它的功能是保存代码片段, 预先准备好代码, 并在需要的时候执行.&lt;br&gt;
    
    </summary>
    
      <category term="Block" scheme="http://blog.xiaodongwang.com/categories/Block/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/Block/iOS/"/>
    
    
      <category term="传值回调" scheme="http://blog.xiaodongwang.com/tags/%E4%BC%A0%E5%80%BC%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>RunLoopManagement</title>
    <link href="http://blog.xiaodongwang.com/2016/11/09/43478/"/>
    <id>http://blog.xiaodongwang.com/2016/11/09/43478/</id>
    <published>2016-11-09T15:14:32.000Z</published>
    <updated>2018-05-17T12:20:14.825Z</updated>
    
    <content type="html"><![CDATA[<p>运行循环是与线程相关的基础架构的一部分。一个运行循环是指用于安排工作，并协调接收传入事件的事件处理循环。运行循环的目的是在有工作要做的时候保持你的线程忙，当没有时候让线程进入睡眠状态。运行循环管理不是完全自动的。<a id="more"></a>您仍然必须设计线程的代码，以便在适当的时候启动运行循环，并响应传入的事件。Cocoa和Core Foundation都提供运行循环对象来帮助你配置和管理线程的运行循环。您的应用程序不需要显式创建这些对象; 每个线程（包括应用程序的主线程）都有一个关联的运行循环对象。但是，只有次要线程需要显式运行其运行循环。应用程序框架自动设置并在主线程上运行运行循环，作为应用程序启动过程的一部分。以下各节提供了有关运行循环的更多信息以及如何为应用程序配置它们。有关运行循环对象的更多信息，请参阅NSRunLoop类参考和CFRunLoop参考。<br><!-- TOC --></p><h1 id="一个运行循环的解剖"><a href="#一个运行循环的解剖" class="headerlink" title="一个运行循环的解剖"></a>一个运行循环的解剖</h1><p>运行循环非常像它的名字的声音。这是一个循环，你的线程进入并用来运行事件处理程序来响应传入的事件。您的代码提供了用于实现循环，换句话说，你的代码提供了运行的实际环部控制语句while或for循环驱动运行循环。在循环中，使用运行循环对象来“运行”接收事件的事件处理代码，并调用已安装的处理程序。<br>运行循环接收来自两种不同类型的源的事件。输入源提供异步事件，通常是来自另一个线程或不同应用程序的消息。定时器源提供同步事件，发生在预定时间或重复间隔。这两种类型的源使用特定于应用程序的处理程序来处理事件到达时。<br>图3-1显示了运行循环和各种来源的概念结构。输入源将异步事件传递给相应的处理程序，并使该runUntilDate:方法（在线程的关联NSRunLoop对象上调用）退出。定时器源将事件传递到其处理程序例程，但不会导致运行循环退出。</p><p>除了处理输入源之外，运行循环还会生成有关运行循环行为的通知。注册的运行循环观察者可以接收这些通知，并使用它们在线程上执行额外的处理。您可以使用Core Foundation在线程上安装运行循环观察器。</p><p>以下部分提供了有关运行循环的组件和运行模式的更多信息。他们还描述了事件处理期间在不同时间生成的通知。</p><h2 id="运行循环模式"><a href="#运行循环模式" class="headerlink" title="运行循环模式"></a>运行循环模式</h2><p>一个运行的循环模式是输入源和定时器的集合进行监测和运行循环观察员集合通知。每次运行运行循环时，都可以指定（显式或隐式）特定的“模式”来运行。在运行循环的过程中，只有与该模式相关的源被监视并被允许传送它们的事件。（类似地，只有与该模式相关的观察者被通知运行循环的进度。）与其他模式相关的源保持到任何新的事件，直到随后以适当的模式通过循环。<br>在你的代码中，你可以通过名字来识别模式。Cocoa和Core Foundation都定义了一个默认模式和几个常用模式，以及用于在代码中指定这些模式的字符串。您可以通过为模式名称指定自定义字符串来定义自定义模式。尽管分配给自定义模式的名称是任意的，但这些模式的内容却不是。您必须确保将一个或多个输入源，定时器或运行循环观察器添加到您创建的任何模式中，以使其有用。<br>您可以使用模式在特定的运行循环中过滤掉不需要的来源的事件。大多数情况下，您需要在系统定义的“默认”模式下运行您的运行循环。然而，模态面板可能以“模态”模式运行。在这种模式下，只有与模式面板相关的源才会将事件传递给线程。对于辅助线程，可以使用自定义模式来防止低优先级的源在时间关键型操作期间传递事件。</p><div class="alert info no-icon"><p>注意：模式基于事件的来源而不是事件的类型进行区分。例如，您不会使用模式来匹配仅鼠标按下事件或仅键盘事件。您可以使用模式来侦听不同的端口集，临时挂起定时器，或者更改当前正在监视的源和运行循环观察器。</p></div><p>下表列出了Cocoa和Core Foundation定义的标准模式以及何时使用该模式的描述。名称列列出了用于在代码中指定模式的实际常量。</p><table><thead><tr><th style="text-align:left"><code>模式</code></th><th style="text-align:center"><code>名称</code></th><th style="text-align:right"><code>描述</code></th></tr></thead><tbody><tr><td style="text-align:left">默认</td><td style="text-align:center"><code>NSDefaultRunLoopMode （Cocoa）</code> <code>kCFRunLoopDefaultMode （Core Foundation）</code></td><td style="text-align:right">默认模式是大多数操作使用的模式。大多数情况下，您应该使用此模式启动运行循环并配置输入源。</td></tr><tr><td style="text-align:left">连接</td><td style="text-align:center"><span class="highlight-text primary">NSConnectionReplyMode （可可）</span></td><td style="text-align:right">Cocoa使用这个模式和NSConnection对象一起来监视回复。你应该很少需要自己使用这个模式。</td></tr><tr><td style="text-align:left">语气</td><td style="text-align:center"><code>NSModalPanelRunLoopMode（Cocoa）</code></td><td style="text-align:right">可可使用这种模式来识别用于模态面板的事件。</td></tr><tr><td style="text-align:left">事件跟踪</td><td style="text-align:center"><code>NSEventTrackingRunLoopMode（Cocoa）</code></td><td style="text-align:right">Cocoa使用这种模式来限制鼠标拖拽循环和其他类型的用户界面追踪循环中的传入事件。</td></tr><tr><td style="text-align:left">共同的模式</td><td style="text-align:center"><code>NSRunLoopCommonModes （Cocoa）kCFRunLoopCommonModes （Core Foundation）</code></td><td style="text-align:right">这是一个可配置的常用模式组。将输入源与此模式关联也会将其与组中的每个模式相关联。对于Cocoa应用程序，这个集合默认包括默认，模态和事件跟踪模式。核心基础最初只包含默认模式。您可以使用该CFRunLoopAddCommonMode功能将自定义模式添加到该设置。</td></tr></tbody></table><h2 id="输入源"><a href="#输入源" class="headerlink" title="输入源"></a>输入源</h2><p>输入源以异步方式向您的线程传递事件。事件的来源取决于输入源的类型，这通常是两类之一。基于端口的输入源监视您的应用程序的Mach端口。自定义输入源监视自定义的事件源。就你的运行循环而言，输入源是基于端口的还是自定义的都不重要。系统通常实现两种类型的输入源，您可以按原样使用。这两个来源唯一的区别是它们是如何发出信号的。内核自动发送基于端口的源，自定义源必须从另一个线程手动发送信号。<br>创建输入源时，将其分配给运行循环的一个或多个模式。模式会影响在任何特定时刻监视哪些输入源。大多数情况下，您在默认模式下运行运行循环，但您也可以指定自定义模式。如果输入源不处于当前监控的模式，则会生成所有生成的事件，直到运行循环以正确的模式运行。<br>以下各节介绍一些输入源。</p><h2 id="基于端口的来源"><a href="#基于端口的来源" class="headerlink" title="基于端口的来源"></a>基于端口的来源</h2><p>Cocoa和Core Foundation为使用端口相关的对象和函数创建基于端口的输入源提供了内置的支持。例如，在Cocoa中，您根本不需要直接创建输入源。您只需创建一个端口对象并使用将该NSPort端口添加到运行循环的方法。port对象为您处理所需输入源的创建和配置。<br>在Core Foundation中，您必须手动创建端口及其运行循环源。在这两种情况下，您使用的端口类型不透明（相关的功能CFMachPortRef，CFMessagePortRef或CFSocketRef）创建合适的对象。<br>有关如何设置和配置基于端口的自定义源的示例，请参阅配置基于端口的输入源。</p><h2 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h2><p>要创建自定义输入源，您必须使用与CFRunLoopSourceRefCore Foundation中的不透明类型关联的函数。您可以使用多个回调函数来配置自定义输入源。Core Foundation在不同的点调用这些函数来配置源代码，处理所有传入的事件，并在源代码从运行循环中移除时拆除源代码。<br>除了在事件到达时定义自定义源的行为之外，还必须定义事件传递机制。这部分源代码运行在一个单独的线程上，负责为输入源提供数据，并在数据准备好处理时通知它。事件传递机制取决于您，但不必过于复杂。<br>有关如何创建自定义输入源的示例，请参阅定义自定义输入源。有关自定义输入源的参考信息，另请参阅CFRunLoopSource参考。</p><h2 id="Cocoa执行选择来源"><a href="#Cocoa执行选择来源" class="headerlink" title="Cocoa执行选择来源"></a>Cocoa执行选择来源</h2><p>除了基于端口的源代码之外，Cocoa还定义了一个自定义输入源，允许您在任何线程上执行选择器。像基于端口的源一样，执行选择器请求在目标线程上被序列化，减轻了在一个线程上运行多个方法时可能发生的许多同步问题。与基于端口的源不同，执行选择器源在执行选择器之后将自身从运行循环中移除。</p><div class="alert info no-icon"><p>注意：在OS X v10.5之前，执行选择器源主要用于向主线程发送消息，但在OS X v10.5及更高版本和iOS中，可以使用它们向任何线程发送消息。</p></div><p>在另一个线程上执行选择器时，目标线程必须有一个活动的运行循环。对于你创建的线程，这意味着等待直到你的代码明确地启动运行循环。因为主线程启动自己的运行循环，所以只要应用程序调用applicationDidFinishLaunching:应用程序委托的方法，就可以开始在该线程上发出调用 。运行循环每次通过循环处理所有排队的执行选择器调用，而不是在每个循环迭代中处理一个。<br>下表列出了NSObject可用于在其他线程上执行选择器的方法。因为这些方法已经声明了NSObject，所以你可以在任何有权访问Objective-C对象的线程中使用它们，包括POSIX线程。这些方法实际上不会创建一个新线程来执行选择器。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>performSelectorOnMainThread: withObject:waitUntilDone: performSelectorOnMainThread: withObject:waitUntilDone:modes:</code></td><td>在该线程的下一个运行循环中执行应用程序主线程上的指定选择器。这些方法给你选择阻塞当前的线程，直到执行选择器。</td></tr><tr><td><code>performSelector:onThread: withObject:waitUntilDone: performSelector:onThread: withObject:waitUntilDone:modes:</code></td><td>在您拥有NSThread对象的任何线程上执行指定的选择器。这些方法给你选择阻塞当前的线程，直到执行选择器。</td></tr><tr><td><code>performSelector: withObject:afterDelay: performSelector: withObject:afterDelay:inModes:</code></td><td>在下一个运行循环周期和可选延迟周期之后，在当前线程上执行指定的选择器。由于它一直等到下一个运行循环执行选择器，所以这些方法提供了从当前正在执行的代码中自动缩短的延迟。多个排队选择器按照排队顺序依次执行。</td></tr><tr><td>cancelPreviousPerform RequestsWithTarget: cancelPreviousPerform RequestsWithTarget:selector:object:</td><td>允许您使用performSelector: withObject: afterDelay: or performSelector: withObject: afterDelay: inModes:方法取消发送到当前线程的消息。</td></tr></tbody></table><!--`cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object:`| 允许您使用performSelector:withObject:afterDelay:or performSelector:withObject:afterDelay:inModes:方法取消发送到当前线程的消息。--><h2 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h2><p>定时器源在未来的预设时间将事件同步传递给您的线程。定时器是线程通知自己做某事的一种方式。例如，搜索字段可以使用定时器来在用户的连续击键之间经过一定的时间后启动自动搜索。这个延迟时间的使用使用户有机会在开始搜索之前输入尽可能多的所需搜索字符串。<br>虽然它会生成基于时间的通知，但计时器不是实时机制。像输入源一样，定时器与运行循环的特定模式相关联。如果一个定时器没有处于当前被运行循环监视的模式，那么只有在定时器的一种支持模式下运行循环时才会触发定时器。同样的，如果一个定时器在运行循环处于执行处理程序的过程中触发，定时器会等待下一次通过运行循环来调用它的处理程序。如果运行循环根本没有运行，定时器不会启动。<br>您可以将定时器配置为仅生成一次或重复生成事件。重复计时器会根据预定的开火时间而不是实际的开火时间自动重新安排时间。例如，如果计时器在特定的时间以及之后的每5秒钟发射一次，则即使实际的发射时间被延迟，计划的发射时间将总是以原来的5秒的时间间隔下降。如果开火时间延迟太多，以至于错过了一个或多个预定的开火时间，则计时器仅在错过的时间段内被触发一次。在错过的时间点火之后，定时器重新计划下一个预定的点火时间。<br>有关配置定时器源的更多信息，请参阅配置定时器源。有关参考信息，请参阅NSTimer类参考或CFRunLoopTimer参考。</p><h2 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h2><p>与发生适当异步事件或同步事件时触发的源相比，运行循环观察器在运行循环本身的执行期间会在特定位置触发。您可以使用运行循环观察程序来准备线程来处理给定事件，或者在线程进入睡眠之前准备线程。您可以将运行循环观察程序与运行循环中的以下事件相关联：<br>    •    运行循环的入口。<br>    •    运行循环即将处理计时器时。<br>    •    运行循环即将处理输入源时。<br>    •    当运行循环即将进入睡眠状态时。<br>    •    运行循环唤醒时，但在处理唤醒它的事件之前。<br>    •    从运行循环退出。<br>您可以使用Core Foundation将运行循环观察器添加到应用程序。要创建一个运行循环观察者，可以创建一个CFRunLoopObserverRef不透明类型的新实例。此类型跟踪您的自定义回调函数和它感兴趣的活动。<br>类似于定时器，运行循环观察者可以使用一次或重复使用。一次性观察者在火灾发生后从运行循环中移除，而重复的观察者则保持连接状态。您可以指定观察者在创建时是运行一次还是反复运行。<br>有关如何创建运行循环观察程序的示例，请参阅配置运行循环。有关参考信息，请参阅CFRunLoopObserver参考。</p><h2 id="事件的运行循环顺序"><a href="#事件的运行循环顺序" class="headerlink" title="事件的运行循环顺序"></a>事件的运行循环顺序</h2><p>每次运行它时，线程的运行循环都会处理挂起的事件，并为任何附加的观察者生成通知。它的执行顺序非常具体，如下所示：</p><ol><li>通知观察者已经输入了运行循环。</li><li>通知观察者，任何准备好的计时器即将开火。</li><li>通知观察者，任何不是基于端口的输入源都将被触发。</li><li>触发任何可以触发的非基于端口的输入源。</li><li>如果基于端口的输入源已准备就绪并正在等待触发，请立即处理该事件。转到第9步。</li><li>通知观察者线程即将睡眠。</li><li>使线程进入睡眠状态，直到发生以下事件之一：<ul><li>一个事件到达一个基于端口的输入源。</li><li>计时器启动。</li><li>为运行循环设置的超时值已过期。</li><li>运行循环明确地被唤醒。</li></ul></li><li>通知观察者线程刚刚醒来。</li><li>处理未决事件。<ul><li>如果用户定义的定时器触发，则处理定时器事件并重新启动循环。转到第2步。</li><li>如果输入源被触发，则交付事件。</li><li>如果运行循环被明确唤醒但尚未超时，请重新启动循环。转到第2步。</li></ul></li><li>通知观察者运行循环已经退出。</li></ol><p>由于定时器和输入源的观察者通知在这些事件实际发生之前就被发送，所以通知的时间和实际事件的时间之间可能存在差距。如果这些事件之间的时间很关键，则可以使用睡眠和从睡眠中醒来的通知来帮助您关联实际事件之间的时间。<br>由于定时器和其他周期性事件是在运行运行循环时交付的，因此绕过该循环会中断这些事件的传递。当您通过输入一个循环并重复地从应用程序请求事件来实现鼠标跟踪例程时，就会出现这种行为的典型示例。由于您的代码是直接抓取事件，而不是让应用程序正常调度这些事件，因此在您的鼠标跟踪例程退出并将控制权返回给应用程序之前，激活的定时器将无法触发。<br>运行循环可以使用运行循环对象显式唤醒。其他事件也可能导致运行循环被唤醒。例如，添加另一个非基于端口的输入源会唤醒运行循环，以便可以立即处理输入源，而不是等待其他事件发生。</p><h1 id="何时使用运行循环？"><a href="#何时使用运行循环？" class="headerlink" title="何时使用运行循环？"></a>何时使用运行循环？</h1><p>唯一需要明确运行运行循环的时候是为应用程序创建辅助线程。应用程序主线程的运行循环是一个关键的基础设施。因此，应用程序框架提供了运行主应用程序循环的代码，并自动启动该循环。所述run的方法UIApplication在IOS（或NSApplication在OS X）启动应用程序的主循环的正常启动序列的一部分。如果您使用Xcode模板项目来创建您的应用程序，您不应该显式调用这些例程。<br>对于辅助线程，您需要确定是否需要运行循环，如果是，则自行配置并启动它。在任何情况下，您都不需要启动线程的运行循环。例如，如果您使用线程来执行一些长时间运行和预定义的任务，则可以避免启动运行循环。运行循环适用于需要更多与线程交互的情况。例如，如果您打算执行以下任一操作，则需要启动一个运行循环：</p><ul><li>使用端口或自定义输入源与其他线程通信。</li><li>在线程上使用计时器。</li><li>使用performSelectorCocoa应用程序中的任何…方法。</li><li>保持线程执行定期任务。</li></ul><p>如果您选择使用运行循环，则配置和设置很简单。就像所有的线程编程一样，你应该有一个在适当的情况下退出你的辅助线程的计划。通过让它退出而不是强制终止一个线程总是更好。有关如何配置和退出运行循环的信息，请参见使用运行循环对象。</p><h1 id="使用运行循环对象"><a href="#使用运行循环对象" class="headerlink" title="使用运行循环对象"></a>使用运行循环对象</h1><p>运行循环对象提供了将输入源，定时器和运行循环观察器添加到运行循环并运行的主界面。每个线程都有一个与之关联的运行循环对象。在Cocoa中，这个对象是NSRunLoop类的一个实例。在低级应用程序中，它是一个指向CFRunLoopRef不透明类型的指针。</p><h2 id="获取运行循环对象"><a href="#获取运行循环对象" class="headerlink" title="获取运行循环对象"></a>获取运行循环对象</h2><p>要获取当前线程的运行循环，请使用以下其中一项：</p><ul><li>在Cocoa应用程序中，使用currentRunLoop类的方法NSRunLoop来检索一个NSRunLoop对象。</li><li>使用该CFRunLoopGetCurrent功能。</li></ul><p>虽然它们不是免费的桥接类型，但是在需要时可以CFRunLoopRef从NSRunLoop对象中获取不透明的类型。本NSRunLoop类定义了一个getCFRunLoop返回的方法CFRunLoopRef类型，你可以传递给Core Foundation的例程。由于两个对象都引用相同的运行循环，因此可以根据需要将调用混合到NSRunLoop对象和CFRunLoopRef不透明类型。</p><h2 id="配置运行循环"><a href="#配置运行循环" class="headerlink" title="配置运行循环"></a>配置运行循环</h2><p>在辅助线程上运行运行循环之前，必须至少添加一个输入源或计时器。如果运行循环没有任何监视源，当您尝试运行它时，它会立即退出。有关如何将源添加到运行循环的示例，请参阅配置运行循环源。<br>除了安装源代码之外，还可以安装运行循环观察器，并使用它们来检测运行循环的不同执行阶段。要安装一个运行循环观察者，可以创建一个CFRunLoopObserverRef不透明类型，并使用该CFRunLoopAddObserver函数将其添加到运行循环中。运行循环观察者必须使用Core Foundation创建，即使对于Cocoa应用程序也是如此。<br>下面代码显示了将运行循环观察器连接到其运行循环的线程的主例程。该示例的目的是向您展示如何创建一个运行循环观察器，因此代码只需设置一个运行循环观察器即可监视所有运行循环活动。基本处理程序例程（未显示）只是在处理计时器请求时记录运行循环活动。</p><figure class="highlight objectivec"><figcaption><span>清单3-1:创建一个运行循环观察者</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- （<span class="keyword">void</span>）threadMain</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="comment">//应用程序使用垃圾回收，所以不需要autorelease池。</span></div><div class="line">    <span class="built_in">NSRunLoop</span> * myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">    <span class="comment">//创建一个运行循环观察器并将其附加到运行循环中。</span></div><div class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>，<span class="keyword">self</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>&#125;;</div><div class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>（kCFAllocatorDefault，</div><div class="line">            kCFRunLoopAllActivities，<span class="literal">YES</span>，<span class="number">0</span>，＆myRunLoopObserver，＆context）;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (observer)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CFRunLoopRef</span> cfLoop = [myRunLoop getCFRunLoop];</div><div class="line">        <span class="built_in">CFRunLoopAddObserver</span>（cfLoop，observer，kCFRunLoopDefaultMode）;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//创建和计划定时器。</span></div><div class="line"></div><div class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span></div><div class="line"></div><div class="line">                selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">NSInteger</span> loopCount = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//运行循环10次，让定时器启动。</span></div><div class="line"></div><div class="line">        [myRunLoop runUntilDate：[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow：<span class="number">1</span>]];</div><div class="line"></div><div class="line">        loopCount--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>（loopCount）;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为长效线程配置运行循环时，最好添加至少一个输入源来接收消息。尽管只能连接一个定时器才能进入运行循环，但是一旦定时器触发，它通常是无效的，这会导致运行循环退出。附加一个重复计时器可以使运行循环运行一段较长的时间，但会涉及周期性地启动计时器来唤醒线程，这实际上是另一种轮询形式。相反，输入源等待事件发生，保持线程睡着，直到它发生。</p><h2 id="启动运行循环"><a href="#启动运行循环" class="headerlink" title="启动运行循环"></a>启动运行循环</h2><p>启动运行循环仅适用于应用程序中的辅助线程。运行循环必须至少有一个输入源或定时器来监视。如果没有连接，运行循环立即退出。<br>有几种启动运行循环的方式，包括：</p><ul><li>无条件</li><li>有一个设定的时间限制</li><li>在特定模式下</li></ul><p>无条件地进入你的运行循环是最简单的选择，但也是最不可取的。无条件地运行你的运行循环把线程放到一个永久的循环中，这使你很少控制运行循环本身。您可以添加和删除输入源和定时器，但停止运行循环的唯一方法是杀死它。在自定义模式下也无法运行运行循环。<br>不要无条件地运行一个运行循环，最好用一个超时值来运行运行循环。当使用超时值时，运行循环运行直到事件到达或分配的时间到期。如果事件到达，则将该事件分派给处理程序进行处理，然后运行循环退出。您的代码然后可以重新启动运行循环来处理下一个事件。如果分配的时间到期，您可以简单地重新启动运行循环或使用时间做任何需要的管家。<br>除了超时值之外，还可以使用特定模式运行运行循环。模式和超时值不是相互排斥的，在启动运行循环时都可以使用。模式限制将事件传递到运行循环的源类型，在运行循环模式中有更详细的描述。<br>程序清单3-2显示了一个线程主入口例程的框架版本。这个例子的关键部分显示了运行循环的基本结构。本质上，您将输入源和定时器添加到运行循环，然后重复调用其中一个例程来启动运行循环。每次运行循环例程返回时，都会检查是否有任何可能导致退出线程的情况。该示例使用Core Foundation运行循环例程，以便它可以检查返回结果并确定运行循环退出的原因。NSRunLoop如果您使用Cocoa并且不需要检查返回值，也可以使用类的方法以类似的方式运行运行循环。（有关调用NSRunLoop类的方法的运行循环的示例，请参见清单3-14）。</p><figure class="highlight objectivec"><figcaption><span>清单3-2:运行一个运行循环</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)skeletonThreadMain</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 如果不使用垃圾回收，在这里设置一个autorelease池。</span></div><div class="line">    <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</div><div class="line">    <span class="comment">// 将你的源或定时器添加到运行循环中，并执行其他任何设置。</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 启动运行循环，但在处理完每个源之后返回。</span></div><div class="line">        SInt32    result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</div><div class="line">        <span class="comment">// 如果一个源明确地停止了运行循环，或者没有</span></div><div class="line">        <span class="comment">// 源或定时器，继续并退出。</span></div><div class="line">        <span class="keyword">if</span> ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</div><div class="line">            done = <span class="literal">YES</span>;</div><div class="line">        <span class="comment">// 检查任何其他退出条件，并设置</span></div><div class="line">        <span class="comment">// 根据需要完成变量</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!done);</div><div class="line">    <span class="comment">// 在这里清理代码 一定要释放任何分配的autorelease池。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以递归地运行一个运行循环。换句话说，您可以调用CFRunLoopRun，CFRunLoopRunInMode或NSRunLoop从输入源或定时器的处理程序例程中启动运行循环的任何方法。这样做时，可以使用任何您想要运行嵌套运行循环的模式，包括外部循环使用的模式。</p><h2 id="退出运行循环"><a href="#退出运行循环" class="headerlink" title="退出运行循环"></a>退出运行循环</h2><p>在处理事件之前，有两种方法可以使运行循环退出：</p><ul><li>配置运行循环以超时值运行。</li><li>告诉运行循环停止。</li></ul><p>如果可以管理它，使用超时值肯定是首选。指定一个超时值可以让运行循环完成所有的正常处理，包括在退出之前传递通知来运行循环观察器。<br>显式停止运行循环CFRunLoopStop会产生类似于超时的结果。运行循环发出任何剩余的运行循环通知，然后退出。不同的是，您可以在无条件启动的运行循环中使用这种技术。<br>尽管删除运行循环的输入源和定时器也可能导致运行循环退出，但这不是停止运行循环的可靠方法。一些系统例程将输入源添加到运行循环中以处理所需的事件。因为你的代码可能不知道这些输入源，所以它将无法删除它们，这将阻止运行循环退出。</p><h2 id="线程安全和运行循环对象"><a href="#线程安全和运行循环对象" class="headerlink" title="线程安全和运行循环对象"></a>线程安全和运行循环对象</h2><p>线程安全性取决于您使用哪个API来操作运行循环。Core Foundation中的函数通常是线程安全的，可以从任何线程调用。但是，如果您正在执行的操作会改变运行循环的配置，则尽可能从拥有运行循环的线程执行此操作仍然是一个好习惯。<br>可可NSRunLoop类并不像其核心基础对象那样天生就是线程安全的。如果您正在使用NSRunLoop该类来修改您的运行循环，则只能从拥有该运行循环的同一个线程执行此操作。将输入源或计时器添加到属于不同线程的运行循环中可能会导致代码崩溃或以意外的方式运行。</p><h1 id="配置运行循环源"><a href="#配置运行循环源" class="headerlink" title="配置运行循环源"></a>配置运行循环源</h1><p>以下部分显示了如何在Cocoa和Core Foundation中设置不同类型的输入源的示例。</p><h2 id="定义一个自定义的输入源"><a href="#定义一个自定义的输入源" class="headerlink" title="定义一个自定义的输入源"></a>定义一个自定义的输入源</h2><p>创建自定义输入源包括定义以下内容：</p><ul><li>您希望输入源处理的信息。</li><li>调度程序让有兴趣的客户知道如何联系您的输入源。</li><li>处理程序例程，用于执行任何客户端发送的请求。</li><li>取消例程以使输入源无效。</li></ul><p>由于您创建了一个自定义输入源来处理自定义信息，因此实际配置的设计灵活。调度程序，处理程序和取消例程是几乎总是需要用于自定义输入源的关键例程。然而，大部分输入源行为的其余部分都发生在这些处理程序之外。例如，您可以定义将数据传递到输入源的机制，并将输入源的存在传递给其他线程。<br>图3-2显示自定义输入源的示例配置。在这个例子中，应用程序的主线程保持对输入源，该输入源的自定义命令缓冲区以及安装输入源的运行循环的引用。当主线程有一个任务想要切换到工作线程时，它将一个命令发送到命令缓冲区以及工作线程启动任务所需的任何信息。（因为工作线程的主线程和输入源都可以访问命令缓冲区，所以访问必须是同步的。）一旦命令发布，主线程就会发信号通知输入源并唤醒工作线程的运行循环。在收到唤醒命令后，运行循环会调用输入源的处理程序，该输入源处理命令缓冲区中的命令。<br><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="图3-2操作自定义输入源"><br>以下各节将解释上图中自定义输入源的实现，并显示您需要实现的关键代码。</p><h3 id="定义输入源"><a href="#定义输入源" class="headerlink" title="定义输入源"></a>定义输入源</h3><p>定义自定义输入源需要使用Core Foundation例程来配置运行循环源并将其附加到运行循环。虽然基本的处理程序是基于C语言的函数，但是这并不妨碍您为这些函数编写包装，并使用Objective-C或C ++来实现代码的主体。<br>图3-2中介绍的输入源使用Objective-C对象来管理命令缓冲区并与运行循环协调。清单3-3显示了这个对象的定义。该RunLoopSource对象管理命令缓冲区，并使用该缓冲区接收来自其他线程的消息。此列表还显示了RunLoopContext对象的定义，它实际上只是一个用于传递RunLoopSource对象的容器对象，并且是对应用程序主线程的运行循环引用。</p><figure class="highlight objectivec"><figcaption><span>清单3-3:自定义输入源对象定义</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopSource</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRunLoopSourceRef</span> runLoopSource;</div><div class="line">    <span class="built_in">NSMutableArray</span>* commands;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop;</div><div class="line">- (<span class="keyword">void</span>)invalidate;</div><div class="line"></div><div class="line"><span class="comment">// Handler方法</span></div><div class="line">- (<span class="keyword">void</span>)sourceFired;</div><div class="line"></div><div class="line"><span class="comment">// 用于注册要处理的命令的客户端界面</span></div><div class="line">- (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data;</div><div class="line">- (<span class="keyword">void</span>)fireAllCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 这些是CFRunLoopSourceRef回调函数。</span></div><div class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info);</div><div class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line"></div><div class="line"><span class="comment">// RunLoopContext是注册输入源期间使用的容器对象。</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopContext</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRunLoopRef</span>        runLoop;</div><div class="line">    RunLoopSource*        source;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CFRunLoopRef</span> runLoop;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RunLoopSource* source;</div><div class="line">- (<span class="keyword">id</span>)initWithSource:(RunLoopSource*)src andLoop:(<span class="built_in">CFRunLoopRef</span>)loop;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>尽管Objective-C代码管理输入源的自定义数据，但将输入源附加到运行循环中需要使用基于C的回调函数。当你将运行循环源连接到你的运行循环时，将会调用第一个函数，如代码3-4所示。因为这个输入源只有一个客户端（主线程），所以它使用调度程序函数来发送一个消息来向该线程上的应用程序委托注册自己。代表想要与输入源进行通信时，它使用RunLoopContext对象中的信息来执行此操作。</p><figure class="highlight objectivec"><figcaption><span>清单3-4:调度运行循环源</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine（<span class="keyword">void</span> * info，<span class="built_in">CFRunLoopRef</span> rl，<span class="built_in">CFStringRef</span>模式）</div><div class="line">&#123;</div><div class="line">    RunLoopSource * obj =（RunLoopSource *）info;</div><div class="line">    AppDelegate * del = [AppDelegate sharedAppDelegate];</div><div class="line">    RunLoopContext * theContext = [[RunLoopContext alloc] initWithSource：obj andLoop：rl];</div><div class="line">    [del performSelectorOnMainThread：<span class="keyword">@selector</span>（registerSource :)</div><div class="line">                                withObject：theContext waitUntilDone：<span class="literal">NO</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中一个最重要的回调函数是用于在输入源发送信号时处理自定义数据的回调函数。清单3-5显示了与RunLoopSource对象关联的执行回调例程。这个函数简单地把请求做的工作转发给sourceFired方法，然后处理命令缓冲区中的所有命令。<br><figure class="highlight objectivec"><figcaption><span>清单3-5:在输入源中执行工作</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine（<span class="keyword">void</span> * info）</div><div class="line">&#123;</div><div class="line">    RunLoopSource * obj =（RunLoopSource *）info;</div><div class="line">    [obj sourceFired];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果你使用CFRunLoopSourceInvalidate函数从运行循环中删除你的输入源，系统调用你的输入源的取消例程。您可以使用此例程来通知客户端您的输入源不再有效，并且应该删除对它的任何引用。 代码清单3-6显示了在RunLoopSource对象中注册的取消回调例程。此函数将另一个RunLoopContext对象发送给应用程序委托，但是这次要求委托移除对运行循环源的引用。<br><figure class="highlight objectivec"><figcaption><span>清单3-6:使输入源无效</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine（<span class="keyword">void</span> * info，<span class="built_in">CFRunLoopRef</span> rl，<span class="built_in">CFStringRef</span>模式）</div><div class="line">&#123;</div><div class="line">    RunLoopSource * obj =（RunLoopSource *）info;</div><div class="line">    AppDelegate * del = [AppDelegate sharedAppDelegate];</div><div class="line">    RunLoopContext * theContext = [[RunLoopContext alloc] initWithSource：obj andLoop：rl];</div><div class="line">    [del performSelectorOnMainThread：<span class="keyword">@selector</span>（removeSource :)</div><div class="line">                                withObject：theContext waitUntilDone：<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><div class="alert info no-icon"><p>注意：应用程序委托registerSource:和removeSource:方法的代码显示在与输入源的客户端协调中。</p></div><h3 id="在运行循环中安装输入源"><a href="#在运行循环中安装输入源" class="headerlink" title="在运行循环中安装输入源"></a>在运行循环中安装输入源</h3><p>清单3-7显示了init与addToCurrentRunLoop该方法的RunLoopSource类。该init方法创建CFRunLoopSourceRef必须实际连接到运行循环的不透明类型。它传递RunLoopSource对象本身作为上下文信息，以便回调例程有一个指向对象的指针。输入源的安装不会发生，直到工作线程调用addToCurrentRunLoop方法，此时RunLoopSourceScheduleRoutine调用回调函数。一旦输入源被添加到运行循环中，线程就可以运行它的运行循环来等待它。<br><figure class="highlight objectivec"><figcaption><span>清单3-7:安装运行循环源</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRunLoopSourceContext</span>    context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</div><div class="line">                                        &amp;RunLoopSourceScheduleRoutine,</div><div class="line">                                        RunLoopSourceCancelRoutine,</div><div class="line">                                        RunLoopSourcePerformRoutine&#125;;</div><div class="line"></div><div class="line">    runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</div><div class="line">    commands = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</div><div class="line">    <span class="built_in">CFRunLoopAddSource</span>(runLoop, runLoopSource, kCFRunLoopDefaultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="与输入源的客户端协调"><a href="#与输入源的客户端协调" class="headerlink" title="与输入源的客户端协调"></a>与输入源的客户端协调</h3><p>为了使输入源有用，您需要操作它并从另一个线程发出信号。输入源的全部要点是将其关联的线程休眠，直到有事情要做。这个事实需要你的应用程序中的其他线程知道输入源并且有一个与之通信的方法。<br>将输入源首次安装在运行循环中时，向客户端通知输入源的一种方法是发送注册请求。您可以根据需要为您的输入源注册尽可能多的客户端，或者您可以将其注册到某个中央代理机构，然后将您的输入源发布到感兴趣的客户端。清单3-8显示了由应用程序委托定义的注册方法，并在调用RunLoopSource对象的调度程序函数时调用。该方法接收由RunLoopContext对象提供的RunLoopSource对象并将其添加到其源列表中。此列表还显示了从运行循环中删除输入源时用于注销输入源的例程。</p><figure class="highlight objectivec"><figcaption><span>清单3-8:使用应用程序委托注册和删除输入源</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerSource:(RunLoopContext*)sourceInfo;</div><div class="line">&#123;</div><div class="line">    [sourcesToPing addObject:sourceInfo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeSource:(RunLoopContext*)sourceInfo</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span>    objToRemove = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">for</span> (RunLoopContext* context <span class="keyword">in</span> sourcesToPing)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ([context isEqual:sourceInfo])</div><div class="line">        &#123;</div><div class="line">            objToRemove = context;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (objToRemove)</div><div class="line">        [sourcesToPing removeObject:objToRemove];</div><div class="line">&#125;</div></pre></td></tr></table></figure><div class="alert info no-icon"><p>注意：  调用前面清单中的方法的回调函数如清单3-4和清单3-6所示。</p></div><h3 id="发信号输入源"><a href="#发信号输入源" class="headerlink" title="发信号输入源"></a>发信号输入源</h3><p>将数据交给输入源后，客户端必须发出信号并唤醒其运行循环。信号源让运行循环知道源已准备好被处理。而且因为信号发生时线程可能会睡着，所以你应该总是明确地唤醒运行循环。否则可能会导致处理输入源的延迟。<br>清单3-9显示fireCommandsOnRunLoop了RunLoopSource对象的方法。当客户端准备好处理添加到缓冲区的命令时，客户端会调用这个方法。<br><figure class="highlight objectivec"><figcaption><span>清单3-9:唤醒运行循环</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- （<span class="keyword">void</span>）fireCommandsOnRunLoop：（<span class="built_in">CFRunLoopRef</span>）runloop</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRunLoopSourceSignal</span>（runLoopSource）;</div><div class="line">    <span class="built_in">CFRunLoopWakeUp</span>（runloop）;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><div class="alert info no-icon"><p>注意：  您不应该SIGHUP通过发送自定义输入源来尝试处理某种或其他类型的进程级别的信号。核心基金会唤醒运行循环的功能不是信号安全的，不应该在应用程序的信号处理程序中使用。有关信号处理程序例程的更多信息，请参阅sigaction手册页。</p></div><h2 id="配置定时器源"><a href="#配置定时器源" class="headerlink" title="配置定时器源"></a>配置定时器源</h2><p>要创建定时器源，您只需创建一个定时器对象并将其安排在运行循环中。在Cocoa中，您使用NSTimer该类来创建新的计时器对象，而在Core Foundation中使用CFRunLoopTimerRef不透明类型。在内部，这个NSTimer类只是Core Foundation的一个扩展，它提供了一些便利的功能，比如使用相同的方法创建和调度一个定时器的能力。<br>在Cocoa中，您可以使用以下任一类方法一次创建和调度一个计时器：</p><ul><li>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</li><li>scheduledTimerWithTimeInterval:invocation:repeats:</li></ul><p>这些方法创建定时器，并以默认模式（NSDefaultRunLoopMode）将其添加到当前线程的运行循环中。如果你想通过创建你的NSTimer对象然后用addTimer:forMode:方法将它添加到运行循环中，你也可以手动安排一个计时器NSRunLoop。这两种技术基本上都是一样的，但是可以让你对定时器的配置有不同程度的控制。例如，如果您创建计时器并手动将其添加到运行循环中，则可以使用除默认模式之外的其他模式执行此操作。清单3-10显示了如何使用这两种技术创建定时器。第一个定时器的初始延迟时间为1秒，但之后每0.1秒定时触发一次。第二个定时器在最初的0.2秒延迟后开始发射，然后每0.2秒发射一次。</p><figure class="highlight objectivec"><figcaption><span>清单3-10:使用NSTimer创建和安排定时器</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line"><span class="comment">// 创建并安排第一个计时器。</span></div><div class="line"><span class="built_in">NSDate</span>* futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</div><div class="line"><span class="built_in">NSTimer</span>* myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate</div><div class="line">                        interval:<span class="number">0.1</span></div><div class="line">                        target:<span class="keyword">self</span></div><div class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer1:)</div><div class="line">                        userInfo:<span class="literal">nil</span></div><div class="line">                        repeats:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">[myRunLoop addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line"></div><div class="line"><span class="comment">// 创建并安排第二个定时器。</span></div><div class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span></div><div class="line">                        target:<span class="keyword">self</span></div><div class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer2:)</div><div class="line">                        userInfo:<span class="literal">nil</span></div><div class="line">                        repeats:<span class="literal">YES</span>];</div></pre></td></tr></table></figure><p>清单3-11显示了使用Core Foundation函数配置定时器所需的代码。虽然这个例子没有在上下文结构中传递任何用户定义的信息，但是你可以使用这个结构来传递你定时器所需的任何自定义数据。有关此结构内容的更多信息，请参阅CFRunLoopTimer参考中的说明。</p><figure class="highlight objectivec"><figcaption><span>清单3-11:使用Core Foundation创建和计划一个计时器</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>（）;</div><div class="line"><span class="built_in">CFRunLoopTimerContext</span> context = &#123;<span class="number">0</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>&#125;;</div><div class="line"><span class="built_in">CFRunLoopTimerRef</span> timer = <span class="built_in">CFRunLoopTimerCreate</span>（kCFAllocatorDefault，<span class="number">0.1</span>，<span class="number">0.3</span>，<span class="number">0</span>，<span class="number">0</span>，</div><div class="line">                                        ＆myCFTimerCallback，＆context）;</div><div class="line"><span class="built_in">CFRunLoopAddTimer</span>（runLoop，timer，kCFRunLoopCommonModes）;</div></pre></td></tr></table></figure><h2 id="配置基于端口的输入源"><a href="#配置基于端口的输入源" class="headerlink" title="配置基于端口的输入源"></a>配置基于端口的输入源</h2><p>Cocoa和Core Foundation都提供了用于线程间或进程间通信的基于端口的对象。以下部分介绍如何使用几种不同类型的端口设置端口通信。</p><h3 id="配置一个NSMachPort对象"><a href="#配置一个NSMachPort对象" class="headerlink" title="配置一个NSMachPort对象"></a>配置一个NSMachPort对象</h3><p>要建立与NSMachPort对象的本地连接，您需要创建port对象并将其添加到主线程的运行循环中。启动辅助线程时，将相同的对象传递给线程的入口函数。辅助线程可以使用相同的对象将消息发送回主线程。</p><h4 id="实现主线程代码"><a href="#实现主线程代码" class="headerlink" title="实现主线程代码"></a>实现主线程代码</h4><p>清单3-12显示了启动辅助工作线程的主要线程代码。由于Cocoa框架执行许多配置端口和运行循环的干预步骤，因此该launchThread方法明显短于其Core Foundation等价物（清单3-17）; 然而，两者的行为几乎完全相同。一个区别是，不是将本地端口的名称发送给工作线程，而是NSPort直接发送该对象。<br><figure class="highlight objectivec"><figcaption><span>清单3-12:主线程启动方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)launchThread</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</div><div class="line">    <span class="keyword">if</span> (myPort)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 这个类处理传入的端口消息。</span></div><div class="line">        [myPort setDelegate:<span class="keyword">self</span>];</div><div class="line">        <span class="comment">// 将端口安装为当前运行循环的输入源。</span></div><div class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">        <span class="comment">// 分离线程。让工作人员释放端口。</span></div><div class="line">        [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(LaunchThreadWithPort:)</div><div class="line">               toTarget:[MyWorkerClass <span class="keyword">class</span>] withObject:myPort];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了在你的线程之间建立一个双向的通信通道，你可能希望工作线程在检入消息中发送自己的本地端口到你的主线程。收到检入信息后，你的主线程就会知道启动第二个线程的过程很顺利，同时也给你一个发送进一步消息的方法。</p><p>清单3-13显示handlePortMessage:了主线程的方法。数据到达线程本地端口时调用此方法。当检入消息到达时，该方法直接从端口消息中检索辅助线程的端口并将其保存以供以后使用。<br><figure class="highlight objectivec"><figcaption><span>清单3-13:处理Mach端口消息</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kCheckinMessage 100</span></div><div class="line"></div><div class="line"><span class="comment">// 处理来自工作线程的响应。</span></div><div class="line">- (<span class="keyword">void</span>)handlePortMessage:(<span class="built_in">NSPortMessage</span> *)portMessage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> message = [portMessage msgid];</div><div class="line">    <span class="built_in">NSPort</span>* distantPort = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (message == kCheckinMessage)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 获取工作线程的通信端口。</span></div><div class="line">        distantPort = [portMessage sendPort];</div><div class="line">        </div><div class="line">        <span class="comment">// 保留并保存工作端口供以后使用。</span></div><div class="line">        [<span class="keyword">self</span> storeDistantPort:distantPort];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 处理其他消息。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="实现次要线程代码"><a href="#实现次要线程代码" class="headerlink" title="实现次要线程代码"></a>实现次要线程代码</h4><p>对于辅助工作者线程，您必须配置线程并使用指定的端口将信息传回主线程。</p><p>清单3-14显示了用于设置工作线程的代码。为线程创建一个自动释放池之后，该方法创建一个工作者对象来驱动线程执行。工作对象的sendCheckinMessage:方法（如程序清单3-15所示）为工作线程创建一个本地端口，并将一个签入消息发回主线程。<br><figure class="highlight objectivec"><figcaption><span>清单3-14:使用Mach端口启动工作线程</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)LaunchThreadWithPort:(<span class="keyword">id</span>)inData</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span>*  pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 建立这个线程和主线程之间的连接。</span></div><div class="line">    <span class="built_in">NSPort</span>* distantPort = (<span class="built_in">NSPort</span>*)inData;</div><div class="line">    </div><div class="line">    MyWorkerClass*  workerObj = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    [workerObj sendCheckinMessage:distantPort];</div><div class="line">    [distantPort release];</div><div class="line"></div><div class="line">    <span class="comment">// 让运行循环处理事情。</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span></div><div class="line">                            beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (![workerObj shouldExit]);</div><div class="line">    [workerObj release];</div><div class="line">    [pool release];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用时NSMachPort，本地和远程线程可以使用相同的端口对象进行线程之间的单向通信。换句话说，由一个线程创建的本地端口对象成为另一个线程的远程端口对象。<br>清单3-15显示了辅助线程的签入例程。这个方法建立了自己的本地端口以供将来的通信，然后发送一个签入消息回主线程。该方法使用方法中接收的端口对象LaunchThreadWithPort:作为消息的目标。<br><figure class="highlight objectivec"><figcaption><span>清单3-15:使用Mach端口发送登记信息</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 工作线程签入方法</span></div><div class="line">- (<span class="keyword">void</span>)sendCheckinMessage:(<span class="built_in">NSPort</span>*)outPort</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 保留并保存远程端口以供将来使用。</span></div><div class="line">    [<span class="keyword">self</span> setRemotePort:outPort];</div><div class="line"></div><div class="line">    <span class="comment">// 创建并配置工作线程端口。</span></div><div class="line">    <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</div><div class="line">    [myPort setDelegate:<span class="keyword">self</span>];</div><div class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建check-in消息。</span></div><div class="line">    <span class="built_in">NSPortMessage</span>* messageObj = [[<span class="built_in">NSPortMessage</span> alloc] initWithSendPort:outPort</div><div class="line">                                         receivePort:myPort components:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (messageObj)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 完成配置消息并立即发送。</span></div><div class="line">        [messageObj setMsgId:setMsgid:kCheckinMessage];</div><div class="line">        [messageObj sendBeforeDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="配置一个NSMessagePort对象"><a href="#配置一个NSMessagePort对象" class="headerlink" title="配置一个NSMessagePort对象"></a>配置一个NSMessagePort对象</h3><p>要与NSMessagePort对象建立本地连接，您不能简单地在线程之间传递端口对象。远程消息端口必须按名称获取。在Cocoa中实现这一点需要注册本地端口的特定名称，然后将该名称传递给远程线程，以便它可以获取适当的端口对象进行通信。清单3-16显示了您想要使用消息端口的情况下的端口创建和注册过程。<br><figure class="highlight objectivec"><figcaption><span>清单3-16:注册一个消息端口</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSPort</span>* localPort = [[<span class="built_in">NSMessagePort</span> alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 配置对象并将其添加到当前运行循环中。</span></div><div class="line">[localPort setDelegate:<span class="keyword">self</span>];</div><div class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:localPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line"></div><div class="line"><span class="comment">// 使用特定名称注册端口。该名称必须是唯一的。</span></div><div class="line"><span class="built_in">NSString</span>* localPortName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"MyPortName"</span>];</div><div class="line">[[<span class="built_in">NSMessagePortNameServer</span> sharedInstance] registerPort:localPort</div><div class="line">                     name:localPortName];</div></pre></td></tr></table></figure></p><h3 id="在Core-Foundation中配置基于端口的输入源"><a href="#在Core-Foundation中配置基于端口的输入源" class="headerlink" title="在Core Foundation中配置基于端口的输入源"></a>在Core Foundation中配置基于端口的输入源</h3><p>本节介绍如何使用Core Foundation在应用程序的主线程和工作线程之间建立双向通信通道。</p><p>清单3-17显示了应用程序的主线程调用的启动工作线程的代码。代码的第一件事是建立一个CFMessagePortRef不透明类型来监听来自工作线程的消息。工作者线程需要端口的名称来建立连接，以便将字符串值传递给工作线程的入口点函数。在当前的用户环境中，端口名称通常应该是唯一的; 否则，您可能会遇到冲突。<br><figure class="highlight objectivec"><figcaption><span>清单3-17: 将Core Foundation消息端口附加到新线程</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kThreadStackSize        (8 *4096)</span></div><div class="line"></div><div class="line">OSStatus MySpawnThread()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 创建一个本地端口来接收响应。</span></div><div class="line">    <span class="built_in">CFStringRef</span> myPortName;</div><div class="line">    <span class="built_in">CFMessagePortRef</span> myPort;</div><div class="line">    <span class="built_in">CFRunLoopSourceRef</span> rlSource;</div><div class="line">    <span class="built_in">CFMessagePortContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">    Boolean shouldFreeInfo;</div><div class="line"></div><div class="line">    <span class="comment">// 使用端口名称创建一个字符串。</span></div><div class="line">    myPortName = <span class="built_in">CFStringCreateWithFormat</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">"com.myapp.MainThread"</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建端口</span></div><div class="line">    myPort = <span class="built_in">CFMessagePortCreateLocal</span>(<span class="literal">NULL</span>,</div><div class="line">                myPortName,</div><div class="line">                &amp;MainThreadResponseHandler,</div><div class="line">                &amp;context,</div><div class="line">                &amp;shouldFreeInfo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (myPort != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 该端口已成功创建。</span></div><div class="line">        <span class="comment">// 现在为它创建一个运行循环源。</span></div><div class="line">        rlSource = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(<span class="literal">NULL</span>, myPort, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rlSource)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 将源代码添加到当前的运行循环中。</span></div><div class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), rlSource, kCFRunLoopDefaultMode);</div><div class="line"></div><div class="line">            <span class="comment">//一旦安装，这些可以被释放。</span></div><div class="line">            <span class="built_in">CFRelease</span>(myPort);</div><div class="line">            <span class="built_in">CFRelease</span>(rlSource);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建线程并继续处理。</span></div><div class="line">    <span class="built_in">MPTaskID</span>  taskID;</div><div class="line">    <span class="keyword">return</span>(<span class="built_in">MPCreateTask</span>(&amp;ServerThreadEntryPoint,</div><div class="line">                    (<span class="keyword">void</span>*)myPortName,</div><div class="line">                    kThreadStackSize,</div><div class="line">                    <span class="literal">NULL</span>,</div><div class="line">                    <span class="literal">NULL</span>,</div><div class="line">                    <span class="literal">NULL</span>,</div><div class="line">                    <span class="number">0</span>,</div><div class="line">                    &amp;taskID));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在安装了端口和启动线程的情况下，主线程可以在等待线程检入的情况下继续执行正常的执行。当检入信息到达时，它将被分派到主线程的MainThreadResponseHandler函数中，如清单3-18所示。该函数提取工作线程的端口名称，并为将来的通信创建一个管道。<br><figure class="highlight objectivec"><figcaption><span>清单3-18:接收签入消息</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kCheckinMessage 100</span></div><div class="line"></div><div class="line"><span class="comment">// 主线程端口消息处理程序</span></div><div class="line"><span class="built_in">CFDataRef</span> MainThreadResponseHandler(<span class="built_in">CFMessagePortRef</span> local,</div><div class="line">                    SInt32 msgid,</div><div class="line">                    <span class="built_in">CFDataRef</span> data,</div><div class="line">                    <span class="keyword">void</span>* info)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (msgid == kCheckinMessage)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CFMessagePortRef</span> messagePort;</div><div class="line">        <span class="built_in">CFStringRef</span> threadPortName;</div><div class="line">        <span class="built_in">CFIndex</span> bufferLength = <span class="built_in">CFDataGetLength</span>(data);</div><div class="line">        <span class="built_in">UInt8</span>* buffer = <span class="built_in">CFAllocatorAllocate</span>(<span class="literal">NULL</span>, bufferLength, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="built_in">CFDataGetBytes</span>(data, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, bufferLength), buffer);</div><div class="line">        threadPortName = <span class="built_in">CFStringCreateWithBytes</span> (<span class="literal">NULL</span>, buffer, bufferLength, kCFStringEncodingASCII, <span class="literal">FALSE</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 您必须按名称获取远程消息端口。</span></div><div class="line">        messagePort = <span class="built_in">CFMessagePortCreateRemote</span>(<span class="literal">NULL</span>, (<span class="built_in">CFStringRef</span>)threadPortName);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (messagePort)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 保留并保存线程的通信端口以备将来参考。</span></div><div class="line">            AddPortToListOfActiveThreads(messagePort);</div><div class="line"></div><div class="line">            <span class="comment">// 由于端口被前一个函数保留，释放</span></div><div class="line">            <span class="comment">// 在这里</span></div><div class="line">            <span class="built_in">CFRelease</span>(messagePort);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 清理.</span></div><div class="line">        <span class="built_in">CFRelease</span>(threadPortName);</div><div class="line">        <span class="built_in">CFAllocatorDeallocate</span>(<span class="literal">NULL</span>, buffer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 处理其他消息.</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在配置主线程的情况下，剩下的唯一东西是新创建的工作线程创建自己的端口并进行检入。清单3-19显示了工作线程的入口点函数。该函数提取主线程的端口名称，并使用它来创建远程连接回主线程。然后该函数为自己创建一个本地端口，在该线程的运行循环中安装该端口，并向包含本地端口名称的主线程发送一个签入消息。</p><figure class="highlight objectivec"><figcaption><span>清单3-19:设置线程结构</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">OSStatus ServerThreadEntryPoint(<span class="keyword">void</span>* param)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 创建远程端口到主线程。</span></div><div class="line">    <span class="built_in">CFMessagePortRef</span> mainThreadPort;</div><div class="line">    <span class="built_in">CFStringRef</span> portName = (<span class="built_in">CFStringRef</span>)param;</div><div class="line">    </div><div class="line">    mainThreadPort = <span class="built_in">CFMessagePortCreateRemote</span>(<span class="literal">NULL</span>, portName);</div><div class="line"></div><div class="line">    <span class="comment">// 释放在param中传递的字符串。</span></div><div class="line">    <span class="built_in">CFRelease</span>(portName);</div><div class="line"></div><div class="line">    <span class="comment">// 为工作线程创建一个端口。</span></div><div class="line">    <span class="built_in">CFStringRef</span> myPortName = <span class="built_in">CFStringCreateWithFormat</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">"com.MyApp.Thread-%d"</span>), <span class="built_in">MPCurrentTaskID</span>());</div><div class="line"></div><div class="line">    <span class="comment">// 将端口存储在此线程的上下文信息中以供日后参考。</span></div><div class="line">    <span class="built_in">CFMessagePortContext</span> context = &#123;<span class="number">0</span>, mainThreadPort, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">    Boolean shouldFreeInfo;</div><div class="line">    Boolean shouldAbort = <span class="literal">TRUE</span>;</div><div class="line"></div><div class="line">    <span class="built_in">CFMessagePortRef</span> myPort = <span class="built_in">CFMessagePortCreateLocal</span>(<span class="literal">NULL</span>,</div><div class="line">                myPortName,</div><div class="line">                &amp;ProcessClientRequest,</div><div class="line">                &amp;context,</div><div class="line">                &amp;shouldFreeInfo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldFreeInfo)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 不能创建一个本地端口，所以杀死线程。</span></div><div class="line">        <span class="built_in">MPExit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">CFRunLoopSourceRef</span> rlSource = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(<span class="literal">NULL</span>, myPort, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!rlSource)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 不能创建一个本地端口，所以杀死线程。</span></div><div class="line">        <span class="built_in">MPExit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将源代码添加到当前的运行循环中。</span></div><div class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), rlSource, kCFRunLoopDefaultMode);</div><div class="line"></div><div class="line">    <span class="comment">// 一旦安装，这些可以被释放。</span></div><div class="line">    <span class="built_in">CFRelease</span>(myPort);</div><div class="line">    <span class="built_in">CFRelease</span>(rlSource);</div><div class="line"></div><div class="line">    <span class="comment">// 打包端口名称并发送签入消息。</span></div><div class="line">    <span class="built_in">CFDataRef</span> returnData = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">CFDataRef</span> outData;</div><div class="line">    <span class="built_in">CFIndex</span> stringLength = <span class="built_in">CFStringGetLength</span>(myPortName);</div><div class="line">    <span class="built_in">UInt8</span>* buffer = <span class="built_in">CFAllocatorAllocate</span>(<span class="literal">NULL</span>, stringLength, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="built_in">CFStringGetBytes</span>(myPortName,</div><div class="line">                <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,stringLength),</div><div class="line">                kCFStringEncodingASCII,</div><div class="line">                <span class="number">0</span>,</div><div class="line">                <span class="literal">FALSE</span>,</div><div class="line">                buffer,</div><div class="line">                stringLength,</div><div class="line">                <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    outData = <span class="built_in">CFDataCreate</span>(<span class="literal">NULL</span>, buffer, stringLength);</div><div class="line"></div><div class="line">    <span class="built_in">CFMessagePortSendRequest</span>(mainThreadPort, kCheckinMessage, outData, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清理线程数据结构。</span></div><div class="line">    <span class="built_in">CFRelease</span>(outData);</div><div class="line">    <span class="built_in">CFAllocatorDeallocate</span>(<span class="literal">NULL</span>, buffer);</div><div class="line">    </div><div class="line">    <span class="comment">// 输入运行循环</span></div><div class="line">    <span class="built_in">CFRunLoopRun</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一旦进入运行循环，所有未来发送到线程端口的事件都由ProcessClientRequest函数处理。该函数的实现取决于线程所做的工作类型，在此不显示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运行循环是与线程相关的基础架构的一部分。一个运行循环是指用于安排工作，并协调接收传入事件的事件处理循环。运行循环的目的是在有工作要做的时候保持你的线程忙，当没有时候让线程进入睡眠状态。运行循环管理不是完全自动的。
    
    </summary>
    
      <category term="多线程" scheme="http://blog.xiaodongwang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/iOS/"/>
    
    
      <category term="RunLoop" scheme="http://blog.xiaodongwang.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage相关类 源码阅读记录（六）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/30/9908/"/>
    <id>http://blog.xiaodongwang.com/2016/08/30/9908/</id>
    <published>2016-08-30T12:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.922Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage其他一些相关类源码阅读记录<br><a id="more"></a><br><!-- TOC --></p><h1 id="UIView-WebCacheOperation"><a href="#UIView-WebCacheOperation" class="headerlink" title="UIView+WebCacheOperation"></a>UIView+WebCacheOperation</h1><p>下面我们先来看看UIView+WebCacheOperation里面都写了些什么:<br>UIView+WebCacheOperation这个分类提供了三个方法,用于操作绑定关系</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SDWebImageManager.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">WebCacheOperation</span>)</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  Set the image load operation (storage in a UIView based dictionary)</span></div><div class="line"><span class="comment">设置图像加载操作（存储在和UIView做绑定的字典里面）</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  @param operation the operation</span></div><div class="line"><span class="comment"> *  @param key       key for storing the operation</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageLoadOperation:(<span class="keyword">id</span>)operation forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  Cancel all operations for the current UIView and key</span></div><div class="line"><span class="comment">  用这个key找到当前UIView上面的所有操作并取消</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  @param key key for identifying the operations</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  Just remove the operations corresponding to the current UIView and key without cancelling them</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  @param key key for identifying the operations</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)sd_removeImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure><p>为了方便管理和找到视图正在进行的一些操作,WebCacheOperation将每一个视图的实例和它正在进行的操作(下载和缓存的组合操作)绑定起来,实现操作和视图一一对应关系,以便可以随时拿到视图正在进行的操作,控制其取消等,如何进行绑定我们在下面分析:<br><code>UIView+WebCacheOperation.m</code>文件内<br><code>- (NSMutableDictionary *)operationDictionary</code>用到了<code>&lt;objc/runtime.h&gt;</code>中定义的两个函数:</p><div class="alert info"><p>•    objc_setAssociatedObject<br>•    objc_getAssociatedObject</p></div><p><code>objc_setAssociatedObject</code>作用是<strong>对已存在的类在扩展中添加自定义的属性 </strong>,通常推荐的做法是添加属性的key最好是static char类型的,通常来说该属性的key应该是常量唯一的.<br><code>objc_getAssociatedObject</code>根据key获得与对象绑定的属性.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)operationDictionary &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">这个loadOperationKey 的定义是:static char loadOperationKey;</span></div><div class="line"><span class="comment">它对应的绑定在UIView的属性是operationDictionary(NSMutableDictionary类型)</span></div><div class="line"><span class="comment">operationDictionary的value是操作,key是针对不同类型视图和不同类型的操作设定的字符串</span></div><div class="line"><span class="comment">注意:&amp;是一元运算符结果是右操作对象的地址(&amp;loadOperationKey返回static char loadOperationKey的地址)</span></div><div class="line"><span class="comment">*/</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line"><span class="comment">//如果可以查到operations,就rerun,反正给视图绑定一个新的,空的operations字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;</div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 取消正在下载的队列</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line"><span class="comment">//如果 operationDictionary可以取到,根据key可以得到与视图相关的操作,取消他们,并根据key值,从operationDictionary里面删除这些操作</span></div><div class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</div><div class="line">                <span class="keyword">if</span> (operation) &#123;</div><div class="line">                    [operation cancel];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</div><div class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">        &#125;</div><div class="line">        [operationDictionary removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="SDWebImagePrefetcher"><a href="#SDWebImagePrefetcher" class="headerlink" title="SDWebImagePrefetcher"></a>SDWebImagePrefetcher</h1><blockquote><p>Prefetch some URLs in the cache for future use. Images are downloaded in low priority.<br>预取缓存中的一些URL以供将来使用。 图像以低优先级下载。</p></blockquote><p>两个代理方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当图像被预取完时调用</span></div><div class="line">- (<span class="keyword">void</span>)imagePrefetcher:(SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(<span class="built_in">NSURL</span> *)imageURL finishedCount:(<span class="built_in">NSUInteger</span>)finishedCount totalCount:(<span class="built_in">NSUInteger</span>)totalCount;</div><div class="line"><span class="comment">//当全部图像被预取完时调用</span></div><div class="line">- (<span class="keyword">void</span>)imagePrefetcher:(SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(<span class="built_in">NSUInteger</span>)totalCount skippedCount:(<span class="built_in">NSUInteger</span>)skippedCount;</div></pre></td></tr></table></figure><p>核心方法循环遍历<code>- (void)startPrefetchingAtIndex:(NSUInteger)index {}</code>调用<code>SDWebImageManager</code>的实例方法<code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:                                         options:                                        progress:                                       completed:</code><br>获取图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startPrefetchingAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.prefetchURLs.count) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">self</span>.requestedCount++;</div><div class="line">    [<span class="keyword">self</span>.manager downloadImageWithURL:<span class="keyword">self</span>.prefetchURLs[index] options:<span class="keyword">self</span>.options progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">        <span class="keyword">if</span> (!finished) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">self</span>.finishedCount++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (image) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">                <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.finishedCount,[<span class="keyword">self</span>.prefetchURLs count]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">                <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.finishedCount,[<span class="keyword">self</span>.prefetchURLs count]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Add last failed</span></div><div class="line">            <span class="keyword">self</span>.skippedCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</div><div class="line">            [<span class="keyword">self</span>.delegate imagePrefetcher:<span class="keyword">self</span></div><div class="line">                            didPrefetchURL:<span class="keyword">self</span>.prefetchURLs[index]</div><div class="line">                             finishedCount:<span class="keyword">self</span>.finishedCount</div><div class="line">                                totalCount:<span class="keyword">self</span>.prefetchURLs.count</div><div class="line">             ];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.prefetchURLs.count &gt; <span class="keyword">self</span>.requestedCount) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.prefetcherQueue, ^&#123;</div><div class="line">                [<span class="keyword">self</span> startPrefetchingAtIndex:<span class="keyword">self</span>.requestedCount];</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.finishedCount == <span class="keyword">self</span>.requestedCount) &#123;</div><div class="line">            [<span class="keyword">self</span> reportStatus];</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionBlock) &#123;</div><div class="line">                <span class="keyword">self</span>.completionBlock(<span class="keyword">self</span>.finishedCount, <span class="keyword">self</span>.skippedCount);</div><div class="line">                <span class="keyword">self</span>.completionBlock = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">self</span>.progressBlock = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>相关阅读：<br><a href="/2016/08/05/review-SDWebImage-Code/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/07/SDWebImageManager/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/09/SDWebImageCache/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/10/SDWebImage-other-interested-parties/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage其他一些相关类源码阅读记录&lt;br&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImageCache 源码阅读记录（五）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/26/28513/"/>
    <id>http://blog.xiaodongwang.com/2016/08/26/28513/</id>
    <published>2016-08-26T14:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.924Z</updated>
    
    <content type="html"><![CDATA[<p>在 SDImageCache.h 中你可以看到关于 SDImageCache 的描述:</p><blockquote><p>SDImageCache maintains a memory cache and an optional disk cache.</p></blockquote><p><code>SDImageCache</code>包括内存缓存和磁盘缓存，内存缓存使用的是继承自 <code>NSCache</code> 的<code>AutoPurgeCache</code>，而磁盘缓存就是基于文件的读写。<br><a id="more"></a><br>先查看<code>SDImageCache</code>的接口，看下都包括哪些功能，然后一一讲解代码。</p><p><strong>存储的功能：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk;</div><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk;</div><div class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure><p>这四个方法的前两个直接调用的第三个，所以我们从第三个方法入手。<br>看代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if memory cache is enabled</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</div><div class="line">    [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果内存缓存可用，就将图片通过 <code>NSCache</code> 的接口 <code>- (void)setObject: forKey: cost: ;</code>存入。计算 cost 的方法是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_STATIC_INLINE <span class="built_in">NSUInteger</span> SDCacheCostForImage(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">    <span class="keyword">return</span> image.size.height * image.size.width * image.scale * image.scale;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是一张图片的像素数量。<br>如果需要存入磁盘，一般情况下我们是将 imageData 直接存入的，但是如果 <code>recalculate</code> 的值是 YES ，或者没有 imageData，那我们就需要将 image 转成 NSData 存入磁盘。具体的实现是判断这个 image 有没有透明通道或者它的前八个字节是不是规定的 PNG 那固定的八个字节，如果是则就调用 <code>UIImagePNGRepresentation</code> 方法转成 NSData ，如果不是那就调用 <code>UIImageJPEGRepresentation</code> 这个方法。有了 data 之后，就要调用那四个存储方法的第四个 <code>storeImageDataToDisk</code> 。<br>通过 key 和 _diskCachePath 得到缓存文件的具体路径，在使用 <code>NSFileManager</code> 中 <code>- (BOOL)createFileAtPath: contents: attributes: ;</code> 方法，将数据写入磁盘中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// disable iCloud backup</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDisableiCloud) &#123;</div><div class="line">        [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这段代码是避免该文件被 iCloud 备份。</p><p>这些读写操作都放到了<code>SDImageCache</code>的一个串行队列中<code>ioQueue</code>。我觉得是因为<code>_fileManager</code>是自己创建的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">    _fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>是为了保障它的线程安全，在 <code>SDImageCache</code> 这个类的所有文件读写操作，都会放到 ioQueue 这个队列执行。而<code>[NSFileManager defaultManager]</code>是系统提供，本身就是线程安全的。</p><p><strong>查询的功能：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure><p>第一个查询方法，在讲 SDWebImageManager 时已经讲过了。<br>第二个方法，就是调用的 NSCache 中的<code>- (nullable ObjectType)objectForKey:</code>的方法。<br>第三个方法中，会先到内存缓存去查找，如果没有命中，则去磁盘缓存中查找，大概就是通过 key 获取具体的路径找到对应的文件取出 NSData ，在经过一些处理转成 image 返回。</p><p><strong>删除的功能:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key withCompletion:(SDWebImageNoParamsBlock)completion;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure><p>前三个方法都是调用的第四个，所以我们看第四个方法就好了。<br>如果有内存缓存则调用<code>NSCache</code>中的<code>- (void)removeObjectForKey:</code>，如果 fromDisk 为 YES，则调用<code>NSFileManager</code>的<code>- (BOOL)removeItemAtPath: error:</code>方法，删除指定缓存文件的路径即可。</p><p><strong>清除的功能:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)clearMemory;</div><div class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;</div><div class="line">- (<span class="keyword">void</span>)clearDisk;</div></pre></td></tr></table></figure><p>第一个方法直接调用<code>NSCache</code>的<code>- (void)removeAllObjects;</code>。第二个方法，直接调用了<code>NSFileManager</code>的<code>- (BOOL)removeItemAtPath: error:</code>删除指定缓存目录的路径即可。第三个方法调用的第二个方法。</p><p><strong>清理的功能：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;</div><div class="line">- (<span class="keyword">void</span>)cleanDisk;</div></pre></td></tr></table></figure><p>清理缓存就是清理掉一些过期的文件和超最大缓存大小限制的文件。</p><p>看第一个方法，首先获取磁盘缓存的路径 URL。然后通过以下代码获取所有缓存文件的一些属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line"></div><div class="line"><span class="comment">// This enumerator prefetches useful properties for our cache files.</span></div><div class="line"><span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                           includingPropertiesForKeys:resourceKeys</div><div class="line">                                               options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                         errorHandler:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure><p>这些属性分别是，是否是目录，文件的修改日期和文件大小。<code>NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</code>这一句则是获取缓存过期的日期。<br>然后 <code>for-in</code> 遍历 <code>fileEnumerator</code> ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">    <span class="comment">// Skip directories.</span></div><div class="line">    <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Remove files that are older than the expiration date;</span></div><div class="line">    <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">    <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">        [urlsToDelete addObject:fileURL];</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Store a reference to this file and account for its total size.</span></div><div class="line">    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">    currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</div><div class="line">    [cacheFiles setObject:resourceValues forKey:fileURL];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取文件路径的属性字典，如果是目录则跳过，比较修改日期和过期日期哪个更晚一些，如果是过期日期则说明该文件过期，放入<code>urlsToDelete</code>数组中。将文件大小累加到<code>currentCacheSize</code>上，并将不是过期的这些缓存文件记录到 <code>cacheFiles</code> 中，key 是文件的 URL ，value 是对应的属性字典。</p><p>之后，遍历<code>urlsToDelete</code>数组删除这些过期文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">    [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，判断没有过期的这些文件的总大小有没有超过最大的缓存大小 <code>self.maxCacheSize</code> 。<br>如果有的话，将 <code>cacheFiles</code> 里的 value 按照文件的修改日期进行排序，返回一个排好序的数组。取 <code>self.maxCacheSize</code> 大小的一半，作为清理缓存的界限<code>const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</code>。遍历排序后的数组，一个个文件删除，删除一个就从之前的总缓存文件大小的值减去删除后的文件大小，再比较有没有小于清理缓存的界限值 <code>desiredCacheSize</code>。如果小于了，则跳出循环。最后在主线程回调 <code>completionBlock();</code> 。这样就达到了清理磁盘缓存的目的。</p><p><strong>计算缓存大小：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)getSize;</div><div class="line">- (<span class="built_in">NSUInteger</span>)getDiskCount;</div><div class="line">- (<span class="keyword">void</span>)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock;</div></pre></td></tr></table></figure><p>第一个方法就是遍历缓存目录的所有文件，获取这些文件路径，通过 <code>[[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]</code> 获得一个字典在通过 <code>fileSize</code> 方法获取文件大小，累加起来就是缓存的大小。<br>第二个和第三个方法都是获取指定缓存路径的 <code>NSDirectoryEnumerator</code> 遍历取对应的值，和上面相差不大，不在赘述。</p><p><strong>查询缓存是否存在：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="built_in">NSString</span> *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;</div><div class="line">- (<span class="built_in">BOOL</span>)diskImageExistsWithKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure><p>这些方法的实现基本就是调用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key]];</div></pre></td></tr></table></figure></p><p>这个方法，不在赘述。</p><p>最后说下 <code>clearMemory</code> ，<code>cleanDisk</code> ，<code>backgroundCleanDisk</code> 的调用时机，在 <code>- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory{}</code> 这个初始化方法中，注册了三个通知分别是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                         selector:<span class="keyword">@selector</span>(clearMemory)</div><div class="line">                                             name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></div><div class="line">                                           object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                         selector:<span class="keyword">@selector</span>(cleanDisk)</div><div class="line">                                             name:<span class="built_in">UIApplicationWillTerminateNotification</span></div><div class="line">                                           object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                         selector:<span class="keyword">@selector</span>(backgroundCleanDisk)</div><div class="line">                                             name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></div><div class="line">                                           object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure><p>报内存警告时调用 <code>clearMemory</code> 清除内存缓存，程序即将终止的时候调用 <code>cleanDisk</code> 清理过期或超大小限制的磁盘缓存，而程序进入后台的时候，调用 <code>backgroundCleanDisk</code> ，在后台执行 <code>cleanDiskWithCompletionBlock</code> 清理任务。</p><p>至此，SDImageCache 的大部分方法就讲解完了。</p><p>相关阅读：<br><a href="/2016/08/05/review-SDWebImage-Code/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/07/SDWebImageManager/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/09/SDWebImageCache/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/10/SDWebImage-other-interested-parties/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 SDImageCache.h 中你可以看到关于 SDImageCache 的描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SDImageCache maintains a memory cache and an optional disk cache.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;SDImageCache&lt;/code&gt;包括内存缓存和磁盘缓存，内存缓存使用的是继承自 &lt;code&gt;NSCache&lt;/code&gt; 的&lt;code&gt;AutoPurgeCache&lt;/code&gt;，而磁盘缓存就是基于文件的读写。&lt;br&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImageDownloaderOperation 源码阅读记录（四）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/20/56144/"/>
    <id>http://blog.xiaodongwang.com/2016/08/20/56144/</id>
    <published>2016-08-20T14:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.928Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImageDownloaderOperation 是下载任务处理者</p><a id="more"></a><p><code>SDWebImageDownloaderOperation</code> 继承自<code>NSOperation</code> ，并且实现了 &lt;<code>SDWebImageOperation</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code>&gt; 这三个协议。继承   <code>NSOperation</code> 的子类执行任务的代码都写在 <code>- (void)start;</code> 或者 <code>- (void)main;</code> 中，我们就从 <code>SDWebImageDownloaderOperation</code> 重写的 <code>- (void)start;</code> 方法入手。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure><p>这段代码的意思是，如果程序进入后台会给程序一段时间，完成未完成的任务，如果时间到了任务还是没有完成则取消这个任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</div><div class="line">    <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">    sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  Create the session for this task</span></div><div class="line"><span class="comment">     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span></div><div class="line"><span class="comment">     *  method calls and completion handler calls.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                      delegate:<span class="keyword">self</span></div><div class="line">                                                 delegateQueue:<span class="literal">nil</span>];</div><div class="line">    session = <span class="keyword">self</span>.ownedSession;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line"><span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line"><span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</div></pre></td></tr></table></figure><p><code>self.unownedSession</code> 是从 <code>SDWebImageDownloader</code> 中传进来的，而如果没有传进来 <code>self.unownedSession</code> 则自己创建一个 <code>self.ownedSession</code>，这个 <code>self.ownedSession</code> 设置的代理是自己，回调的代理方法直接调用这个类里的， 而<code>self.unownedSession</code>  传进来的这种，代理方法就是通过上面介绍过的方式调用到这个类的。上面注释的意思是为 task 创建一个 session，<code>delegateQueue</code> 中传入一个 <code>nil</code>，这样 session 就会创建一个串行的操作队列来执行所有的代理方法和完成处理的调用。<br>继续看代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.dataTask resume];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>resume</code> 开启这个任务，调用下 <code>self.progressBlock</code> 传入初始的值，然后在主线程发送一个开始下载的通知，如果没有 <code>self.dataTask</code> 则调用 <code>self.completedBlock</code> 返回一个 <code>NSError</code> 。<br>下面我们在简单说下 <code>SDWebImageDownloaderOperation</code> 类中这两个 <code>NSURLSessionTaskDelegate</code> 和 <code>NSURLSessionDataDelegate</code>  协议的代理方法。</p><p><strong>NSURLSessionDataDelegate</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark NSURLSessionDataDelegate</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</div></pre></td></tr></table></figure></p><p>在这个方法里检查下 <code>response</code> 的状态码，不正确的话取消任务，<code>completedBlock</code> 回调 <code>NSError</code> 。正确的话，获取下载数据的总大小 <code>expectedContentLength</code> ，并调用 <code>self.progressBlock</code> 。还会创建保存数据流的 <code>NSMutableData</code> 对象，<code>self.imageData = [[NSMutableData alloc] initWithCapacity:expected];</code> 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</div></pre></td></tr></table></figure><p>将每次接收到的数据 data 拼接到之前创建好的 <code>self.imageData</code> 中去，<code>[self.imageData appendData:data];</code> 。如果 option 的要求是 <code>SDWebImageDownloaderProgressiveDownload</code> 则在这里把已有的数据 <code>self.imageData</code> 转成 image ，通过 <code>self.completedBlock</code> 回调出去，注意 finished 参数是 NO。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">    <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用 <code>self.progressBlock</code> 将下载进度回调出去。</p><p><strong>NSURLSessionTaskDelegate</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error;</div></pre></td></tr></table></figure><p>请求完成的回调方法，有 error 则 <code>self.completedBlock(nil, nil, error, YES);</code> ，没有则将 <code>self.imageData</code> 转成 image 回调出去 <code>completionBlock(image, self.imageData, nil, YES);</code> ，当然这里面涉及很多处理的细节和其他情况的判断，就先不说了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler;</div></pre></td></tr></table></figure><p>这段则是针对不同的鉴定场景返回不一样的策略。</p><p>至此，<code>SDWebImageDownloaderOperation</code> 中的这些代理方法就简单的介绍完了。</p><p>相关阅读：<br><a href="/2016/08/05/review-SDWebImage-Code/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/07/SDWebImageManager/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/09/SDWebImageCache/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/10/SDWebImage-other-interested-parties/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImageDownloaderOperation 是下载任务处理者&lt;/p&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImageDownloader 源码阅读记录（三）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/14/18664/"/>
    <id>http://blog.xiaodongwang.com/2016/08/14/18664/</id>
    <published>2016-08-14T09:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.923Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage的图片下载是由<code>SDWebImageDownloader</code>这个类来实现的，它是一个异步下载管理器，下载过程中增加了对图片加载做了优化的处理。而真正实现图片下载的是自定义的一个<code>Operation</code>操作，将该操作加入到下载管理器的操作队列<code>downloadQueue</code>中，<code>Operation</code>操作依赖系统提供的<code>NSURLSession</code>类实现图片的下载。</p><a id="more"></a><blockquote><p>Asynchronous downloader dedicated and optimized for image loading.<br>专用的并且优化的图片异步下载器.</p></blockquote><p>我们还是从<code>SDWebImageDownloader</code>的核心方法入手：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url </div><div class="line">        options:(SDWebImageDownloaderOptions)options </div><div class="line">       progress:(SDWebImageDownloaderProgressBlock)progressBlock </div><div class="line">      completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</div></pre></td></tr></table></figure><p>该方法的大部分代码都放到了一个<code>createCallback</code>的回调中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        ...</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></div><div class="line"><span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</div><div class="line">        <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">        first = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Handle single download of simultaneous download request for the same URL</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">    [callbacksForURL addObject:callbacks];</div><div class="line">    <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (first) &#123;</div><div class="line">        createCallback();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>注释有说，这个 URL 参数不能为空，因为它要作为存储 callbacks 字典的 key，如果它为 nil 则会马上调用 <code>completed block</code> 返回 nil 图片和 nil 数据。<br><code>self.URLCallbacks</code> 是一个 <code>NSMutableDictionary</code> ，它以 URL 作为 key ，维护一个可变数组 <code>callbacksForURL</code>，这个数组里又会存放一个一个的  <code>NSMutableDictionary</code>  用来存储两个 <code>callback</code> 回调方法，分别是以 <code>kProgressCallbackKey</code> 为 key 的 <code>progressBlock</code>  和 以 <code>kCompletedCallbackKey</code>  为 key 的 <code>completedBlock</code> 。代码里还有一个 BOOL first 的变量，如果发现 <code>self.URLCallbacks</code> 中没有这个 URL 的回调数组，那这个 URL 此时就是第一次请求（此时没有相同的 URL 在请求），会调用 <code>createCallback()</code>; 来创建下载的操作，而发现  <code>self.URLCallbacks</code> 中有这个 URL 的回调数组的话，则将对应的那两个回调方法存进 <code>NSMutableDictionary</code> ，在放到之前的回调数组中，且不会再调用 <code>createCallback()</code>; ，这样相同的 URL 不会重复请求下载。当第一个请求下载成功之后，会遍历这个回调数组，将数组里所有的 <code>callback</code> 都执行一遍。这么做的目的就是防止同时有多个相同 URL 的请求发生。</p><p>这段代码使用 <code>dispatch_barrier_sync</code> 将任务放入一个并发队列，目的是在并发队列中，这个任务执行时，不允许别的任务同时执行。因为 <code>downloadImageWithURL:</code> 方法要返回一个遵从<code>&lt;SDWebImageOperation&gt;</code> 的对象，所以要同步执行而不能异步。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SDWebImageDownloader</span></div><div class="line"><span class="comment">// downloadImageWithURL:options:progress:completed: #4</span></div><div class="line"></div><div class="line">[<span class="keyword">self</span> addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123; ... &#125;];</div></pre></td></tr></table></figure><p>我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 <code>NSMutableURLRequest</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SDWebImageDownloader</span></div><div class="line"><span class="comment">// downloadImageWithURL:options:progress:completed: #11</span></div><div class="line"></div><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] </div><div class="line">initWithURL:url </div><div class="line">        cachePolicy:...</div><div class="line">    timeoutInterval:timeoutInterval];</div></pre></td></tr></table></figure><p>这个 request 就用于在之后发送 HTTP 请求.<br>在初始化了这个 request 之后, 又初始化了一个 <code>SDWebImageDownloaderOperation</code> 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 <code>NSOperation</code> 的子类,</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SDWebImageDownloader</span></div><div class="line"><span class="comment">// downloadImageWithURL:options:progress:completed: #20</span></div><div class="line"></div><div class="line">operation = [[SDWebImageDownloaderOperation alloc] </div><div class="line">initWithRequest:request</div><div class="line">                options:options</div><div class="line">               progress:...</div><div class="line">              completed:...</div><div class="line">              cancelled:...&#125;];</div></pre></td></tr></table></figure><p>在 <code>progressBlock</code> 的回调方法里，会通过 <code>sself.URLCallbacks</code> 取出这个 URL 所有 <code>kProgressCallbackKey</code> 的回调方法，并将获取到的 <code>receivedSize</code> 和 <code>expectedSize</code> 的值传入这些方法中调用。<br>在 <code>completedBlock</code> 的回调方法里和 <code>progressBlock</code> 中的一样，取出 <code>kCompletedCallbackKey</code> 对应的回调方法，将获取到的 <code>image</code> ，<code>data</code>，<code>error</code>，<code>finished</code> 的值传入方法中调用，还会删除 <code>sself.URLCallbacks</code> 中这个 URL 的回调数组 ，保障这个 URL 下次可以重新创建新请求。<br>在 <code>cancelBlock</code> 中则只是删除掉  <code>sself.URLCallbacks</code> 中这个 URL 的回调数组。<br>在往下是，给 operation 设置是否应该解压图片的属性，解压图片会提高下载和缓存的性能，但是会消耗较多的内存，如果程序因为占用内存过多而闪退则要把这个属性设置成 NO。</p><p>设置 operation 请求的 <code>NSURLCredential</code> ，用于在请求过程中，服务端要求验证客户端的凭证  <code>- (void)URLSession: task: didReceiveChallenge: completionHandler:</code> 。<br>再往后，是设置 NSOperation 的操作优先级。<code>[wself.downloadQueue addOperation:operation];</code> 是将操作任务加到 <code>NSOperationQueue</code> 队列中，开始任务。最后是设置操作的执行顺序，默认是 FIFO 的先进先出的模式，也可以改成 LIFO 后进先出的栈模式，实现的方法就是添加依赖，前面的操作依赖后面的操作。设置完之后，则 return 这个 operation。<br>到此，<code>SDWebImageDownloader</code> 的这个核心方法就介绍完了。</p><p>还有一点，下载的请求是使用的 <code>NSURLSession</code> ，<code>SDWebImageDownloader</code> 将  <code>NSURLSession</code> 的 delegate 设置成自己，统一接收这些回调方法。在这些回调方法中，会返回一个 <code>NSURLSessionDataTask</code> 通过这个 dataTask 的 taskIdentifier ，我们就可以在 <code>self.downloadQueue.operations</code> 中找到回调方法对应的 operation （SDWebImageDownloaderOperation），每个 operation 中都有这些代理方法，这样在 <code>SDWebImageDownloader</code> 统一接收的回调中用找到的 operation 调用当前的这个代理方法，把参数传到对应的 operation 中。<br>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找到回调方法对应的 operation</span></div><div class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</div><div class="line">    SDWebImageDownloaderOperation *returnOperation = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">for</span> (SDWebImageDownloaderOperation *operation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</div><div class="line">        <span class="keyword">if</span> (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</div><div class="line">            returnOperation = operation;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> returnOperation;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark NSURLSessionDataDelegate</span></div><div class="line"><span class="comment">//调用当前operation的这个代理方法</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></div><div class="line">    SDWebImageDownloaderOperation *dataOperation = [<span class="keyword">self</span> operationWithTask:dataTask];</div><div class="line"></div><div class="line">    [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><p><code>SDWebImageDownloaderOperation</code>  的 <code>- (id)initWithRequest:(NSURLRequest *)request inSession: options: progress: completed: cancelled:;</code> 是下载图片的关键代码，下篇文章我们就来看下<a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation</a> 这个类。</p><p>相关阅读：<br><a href="/2016/08/05/review-SDWebImage-Code/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/07/SDWebImageManager/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/09/SDWebImageCache/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/10/SDWebImage-other-interested-parties/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage的图片下载是由&lt;code&gt;SDWebImageDownloader&lt;/code&gt;这个类来实现的，它是一个异步下载管理器，下载过程中增加了对图片加载做了优化的处理。而真正实现图片下载的是自定义的一个&lt;code&gt;Operation&lt;/code&gt;操作，将该操作加入到下载管理器的操作队列&lt;code&gt;downloadQueue&lt;/code&gt;中，&lt;code&gt;Operation&lt;/code&gt;操作依赖系统提供的&lt;code&gt;NSURLSession&lt;/code&gt;类实现图片的下载。&lt;/p&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImageManager 源码阅读记录（二）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/10/34027/"/>
    <id>http://blog.xiaodongwang.com/2016/08/10/34027/</id>
    <published>2016-08-10T12:14:32.000Z</published>
    <updated>2018-03-09T06:42:21.930Z</updated>
    
    <content type="html"><![CDATA[<p>我们利用<code>SDWebImageManager</code>能做很多其他的有意思的事情。比如给各种view绑定一个URL，就能显示图片的功能，有了Options，就能满足多种应用场景的图片下载任务。管理Cache和Downloader等。<br><a id="more"></a><br><!-- TOC --><br>在 SDWebImageManager.h 中你可以看到关于 SDWebImageManager 的描述:</p><blockquote><p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p></blockquote><p>可以看到, 这个类的主要作用就是为 <code>UIImageView+WebCache</code> 和 <code>SDWebImageDownloader</code>, <code>SDImageCache</code> 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.</p><h1 id="SDWebImageManager核心"><a href="#SDWebImageManager核心" class="headerlink" title="SDWebImageManager核心"></a>SDWebImageManager核心</h1><p>我们去看 SDWebImageManager 的核心方法</p><figure class="highlight objectivec"><figcaption><span>SDWebImageManager的核心方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</div></pre></td></tr></table></figure><p>我们看这个方法前几句：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won't</span></div><div class="line"><span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></div><div class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">    url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></div><div class="line"><span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</div><div class="line">    url = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这块代码的功能是确定 url 是否被正确传入, 如果传入参数的是 <code>NSString</code> 类型就会被转换为 <code>NSURL</code>. 如果转换失败, 那么 url 会被赋值为空, 这个下载的操作就会出错.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">__<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div></pre></td></tr></table></figure><p>当 url 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 <code>SDWebImageOperation</code> 协议的 <code>NSObject</code> 的子类. 这个类的作用是管理多个模块的取消操作，具体是怎么实现的，后面的代码会提到，<code>__weak</code> 修饰是为了防止循环引用。</p><p>下面就是文章最开始提到的功能之一，不可用的 URL 不会一次次重试的功能实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">    isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">    dispatch_main_sync_safe(^&#123;</div><div class="line">        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</div><div class="line">        completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <code>downloader</code> 的下载方法的 <code>completedBlock</code> 中会将下载失败的 <code>URL</code> ，维护到 <code>Set</code> 集合中（黑名单），代码会在后面提到。这段代码的意思是如果发现 url 长度为 0 ，或者是下载失败过的 url ，且没有要求重试则直接创建 <code>NSError</code> 并 回调 completedBlock 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">    [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>manager 维护了一个数组 <code>self.runningOperations</code> ，将所有操作放进去，便于管理。（比如统一调用 cancel ）下面是比较核心的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;...&#125;</div></pre></td></tr></table></figure><p>通过 url 获取用来缓存的 key，尝试去缓存中取图片。<code>queryDiskCacheForKey: done:</code> 方法返回了一个 <code>NSOperation</code> 对象并赋值给了 <code>SDWebImageCombinedOperation</code> 的 <code>cacheOperation</code> ，这个类（<code>SDWebImageCombinedOperation</code>）中还有一个属性 <code>cancelBlock</code> 也会包括一些取消操作。它还实现了协议 <code>&lt;SDWebImageOperation&gt;</code> ，这个协议里只需要实现一个方法，就是 <code>- (void)cancel;</code> 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>而 <code>SDWebImageCombinedOperation</code> 的实现类中，实现了这个 <code>cancel</code> 方法，并调用了这些取消操作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cancel &#123;</div><div class="line">    <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</div><div class="line">        [<span class="keyword">self</span>.cacheOperation cancel];</div><div class="line">        <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cancelBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.cancelBlock();</div><div class="line">        </div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span></div><div class="line">        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span></div><div class="line"><span class="comment">//        self.cancelBlock = nil;</span></div><div class="line">        _cancelBlock = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，调用者只要调用 operation 的 <code>cancel()</code>，就可以统一对多个模块类做取消操作。</p><p>然后看下查询缓存的方法 <code>- (NSOperation *)queryDiskCacheForKey: done:</code> 的实现代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key </div><div class="line">done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 1.首先查看内存缓存,如果查找到,则直接调用doneBlock并返回</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//2.如果内存中没有,则在磁盘中查找,如果找到,则将其放到内存缓存中,并调用doneBlock回调</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line"><span class="comment">//在ioQueue中串行处理所有磁盘缓存</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//创建自动释放池,内存及时释放</span></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">  <span class="comment">//根据图片的url对应的key去磁盘缓存中查找图片</span></div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line"><span class="comment">//如果可以在磁盘中查找到image,并且self.shouldCacheImagesInMemory = YES(默认是YES,if memory cache is enabled)就将image储存到内存缓存中</span></div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">        <span class="comment">//self.memCache是NSCache创建的一个对象,下面的方法是NSCache储存对象的方法,如果你对cost的作用不太了解可以看我另外一篇文章NSCache</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">  <span class="comment">//最后在主线程里面调用doneBlock返回</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div></pre></td></tr></table></figure><p>会先到内存缓存中去查找，如果命中则直接回调，没有命中继续在磁盘缓存中查找。查找任务是异步的，在一个串行队列中，先生成一个 <code>NSOperation</code> 对象返回，也就是赋值给了 <code>operation.cacheOperation</code> 。在查找任务中，会先检测这个 operation 有没有被取消，如果取消则直接 return，这就实现了 <code>SDWebImageCombinedOperation</code> 可以取消查找缓存的操作。之后的代码就是去磁盘缓存中查找图片，且如果需要内存缓存就存进去，最后回调 <code>doneBlock</code>。这段代码被放入到了 <code>@autoreleasepool</code> 中包裹起来，是因为查找出来的图片可能会比较大，占用较多的内存，保障能够及时的回收它。</p><p>现在回到 SDWebImageManager 中继续看，在 <code>queryDiskCacheForKey:</code> 的 <code>doneBlock</code> 中，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果操作被取消，则删除掉 <code>self.runningOperations</code> 的操作，然后 return。<br>接下来会有三个条件分支，我们一个个来看，第一个是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;&#125;</div></pre></td></tr></table></figure><p>image 为空意味着缓存没有命中，<code>SDWebImageRefreshCached</code> 则是就算缓存命中也要下载图片更新缓存，<code>SDWebImageManager</code> 这个类还定义了一个协议并实现一个代理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageManagerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>第一个方法的意思是，是否下载图片，YES 就是下载，NO 就是不下载。第二个方法是，对下载好的图片 image 做 transform 处理，比如可以改成圆角图片等，然后返回，这样缓存的图片也会是 transform 之后的图片。<br>理解了代理方法的意思就可以理解这个条件了，如果缓存没有命中，或需要刷新已有缓存 且 没有实现 <code>imageManager:shouldDownloadImageForURL</code> 的方法（默认是 YES，可以下载图片）则去下载图片。如果实现了这个代理方法返回的是 YES，也会去下载图片。</p><p>看第一个条件里的代码，首先：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">    dispatch_main_sync_safe(^&#123;</div><div class="line">        <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">        <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">        completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>缓存如果命中，且需要更新缓存，则先将缓存图片通过 completedBlock 回调出去，在继续下载图片。在往下就是缓存没有命中或需要更新缓存的情况，所以需要下载图片，但之前先将<code>SDWebImageManager</code> 里 option 的条件映射成 <code>SDWebImageDownloder</code> 里的 option 的条件，下载使用的方法是 <code>SDWebImageDownloder</code> 里下面这个方法。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</div></pre></td></tr></table></figure></p><p>具体实现会在分析 <a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a>  时会说，我们先看 completedBlock 里的逻辑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line"><span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line"><span class="comment">// Do nothing if the operation was cancelled</span></div><div class="line"><span class="comment">//如果操作取消了,不做任何事情</span></div><div class="line"><span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></div><div class="line"><span class="comment">//如果我们调用completedBlock,这个block会和另外一个completedBlock争夺一个对象,因此这个block被调用后会覆盖新的数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里注意避免循环引用，<code>imageDownloader</code> 被 <code>SDWebImageManager</code> 强引用，<code>downloadImageWithURL</code> 的 <code>completedBlock</code> 会被 <code>imageDownloader</code> 的属性 <code>URLCallbacks</code>  数组强引用保存起来，至于为什么这么做后面会讲到。</p><p>然后是发生错误的处理情况：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">   <span class="comment">//进行完成回调</span></div><div class="line">     dispatch_main_sync_safe(^&#123;</div><div class="line">         <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">             completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, finished, url);</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line">   <span class="comment">//将url添加到失败列表里面</span></div><div class="line">     <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">         &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">         <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">             [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>发生错误，并回调。将在确定条件下失败的 URL 放入黑名单，不会反复请求。（通常是 URL 的问题，而不是网络问题）看下 else 之后的代码，稍长一些：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//如果设置了下载失败重试,将url从失败列表中去掉</span></div><div class="line">     <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">         <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">             [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line"><span class="comment">//options包含了SDWebImageRefreshCached选项,且缓存中找到了image且没有下载成功</span></div><div class="line">     <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">         <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line"><span class="comment">// 图片刷新遇到了NSSURLCache中有缓存的状况，不调用完成回调。</span></div><div class="line"> &#125;</div><div class="line"><span class="comment">//图片下载成功并且 设置了需要变形Image的选项且变形的代理方法已经实现</span></div><div class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line"><span class="comment">//全局队列异步执行</span></div><div class="line"> <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">             <span class="comment">//调用代理方法完成图片transform</span></div><div class="line">             <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">             <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                 <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line"></div><div class="line"> <span class="comment">//对已经transform的图片进行缓存</span></div><div class="line">                 [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">             &#125;</div><div class="line">             <span class="comment">//主线程执行完成回调</span></div><div class="line">             dispatch_main_sync_safe(^&#123;</div><div class="line">                 <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                     completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                 &#125;</div><div class="line">             &#125;);</div><div class="line">         &#125;);</div><div class="line">     &#125;</div><div class="line"><span class="comment">//如果没有图片transform的需求并且图片下载完成且图片存在就直接缓存</span></div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">             [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">         &#125;</div><div class="line">    <span class="comment">//主线程完成回调 </span></div><div class="line">         dispatch_main_sync_safe(^&#123;</div><div class="line">             <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                 completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">             &#125;</div><div class="line">         &#125;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>如果 option 是 <code>SDWebImageRetryFailed</code> 则这个 url 从黑名单中删除，给它一个重试的机会。有 <code>downloadedImage</code> 说明图片下载成功，如果是要进行 transform ，则调用 delegate 方法，获取 transform 之后的图片，进行缓存，再调用 <code>completedBlock</code> 。如果不需要 transform 则直接缓存后回调 <code>completedBlock</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置组合操作取消得得回调</span></div><div class="line">operation.cancelBlock = ^&#123;</div><div class="line">    [subOperation cancel];</div><div class="line">    </div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">        <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">            [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这是下载图片的取消操作，调用 <code>NSOperation</code> 的 <code>cancel</code>，从 <code>self.runningOperations</code> 中删除 <code>operation</code>。赋值给 <code>cancelBlock</code> ，交给 <code>SDWebImageCombinedOperation</code> 对象管理。<br>看前面提到的三个分支条件的第二个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">    dispatch_main_sync_safe(^&#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">            completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有 image 说明缓存命中，且没有要重下图片的情况，则直接回调 completedBlock 就可以了。<br>第三个分支条件，它的意思是既没有缓存图片，代理 delegate 也不允许下载图片，那就只能直接回调 completedBlock ，图片参数传 nil 了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Image not in cache and download disallowed by delegate</span></div><div class="line">    dispatch_main_sync_safe(^&#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">        <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到此，SDWebImageManager 的核心方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</div></pre></td></tr></table></figure><p>就介绍完了。</p><p>最后是这个完整核心方法注释</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//条件1:在缓存中没有找到图片或者options选项里面包含了SDWebImageRefreshCached(这两项都需要进行请求网络图片的)</span></div><div class="line"><span class="comment">//条件2:代理允许下载,SDWebImageManagerDelegate的delegate不能响应imageManager:shouldDownloadImageForURL:方法或者能响应方法且方法返回值为YES.也就是没有实现这个方法就是允许的,如果实现了的话,返回YES才是允许</span></div><div class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line"><span class="comment">//如果在缓存中找到了image且options选项包含SDWebImageRefreshCached,先在主线程完成一次回调,使用的是缓存中找的图片</span></div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line"></div><div class="line">                <span class="comment">// 如果在缓存中找到了image但是设置了SDWebImageRefreshCached选项，传递缓存的image，同时尝试重新下载它来让NSURLCache有机会接收服务器端的更新</span></div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 如果没有在缓存中找到image 或者设置了需要请求服务器刷新的选项,则仍需要下载</span></div><div class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line">  </div><div class="line">            <span class="comment">//开始各种options的判断</span></div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">            <span class="comment">// 如果image已经被缓存但是设置了需要请求服务器刷新的选项，强制关闭渐进式选项</span></div><div class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">               <span class="comment">// 如果image已经被缓存但是设置了需要请求服务器刷新的选项，忽略从NSURLCache读取的image</span></div><div class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//创建下载操作,先使用self.imageDownloader下载</span></div><div class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></div><div class="line">                    <span class="comment">//如果操作取消了,不做任何事情</span></div><div class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></div><div class="line">                <span class="comment">//如果我们调用completedBlock,这个block会和另外一个completedBlock争夺一个对象,因此这个block被调用后会覆盖新的数据</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    <span class="comment">//进行完成回调</span></div><div class="line">                    dispatch_main_sync_safe(^&#123;</div><div class="line">                        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, finished, url);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                  <span class="comment">//将url添加到失败列表里面</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果设置了下载失败重试,将url从失败列表中去掉</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">        <span class="comment">//options包含了SDWebImageRefreshCached选项,且缓存中找到了image且没有下载成功</span></div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line"> <span class="comment">// 图片刷新遇到了NSSURLCache中有缓存的状况，不调用完成回调。</span></div><div class="line">                &#125;</div><div class="line">  <span class="comment">//图片下载成功并且 设置了需要变形Image的选项且变形的代理方法已经实现</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line"><span class="comment">//全局队列异步执行                      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></div><div class="line"></div><div class="line">                            <span class="comment">//调用代理方法完成图片transform</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line"></div><div class="line">                <span class="comment">//对已经transform的图片进行缓存</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//主线程执行完成回调</span></div><div class="line">                            dispatch_main_sync_safe(^&#123;</div><div class="line">                                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                    completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                                &#125;</div><div class="line">                            &#125;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line"><span class="comment">//如果没有图片transform的需求并且图片下载完成且图片存在就直接缓存</span></div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                   <span class="comment">//主线程完成回调 </span></div><div class="line">                        dispatch_main_sync_safe(^&#123;</div><div class="line">                            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">       <span class="comment">// 从正在进行的操作列表中移除这组合操作</span></div><div class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                        <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                            [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">          <span class="comment">//设置组合操作取消得得回调</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [subOperation cancel];</div><div class="line">                </div><div class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                    <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                        [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//处理其他情况</span></div><div class="line"><span class="comment">//case1.在缓存中找到图片(代理不允许下载 或者没有设置SDWebImageRefreshCached选项  满足至少一项)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">            <span class="comment">//完成回调</span></div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">          <span class="comment">//从正在进行的操作列表中移除组合操作</span></div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">          <span class="comment">//case2:缓存中没有扎到图片且代理不允许下载</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//主线程执行完成回调</span></div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">          <span class="comment">//从正在执行的操作列表中移除组合操作</span></div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="SDWenImageManager属性"><a href="#SDWenImageManager属性" class="headerlink" title="SDWenImageManager属性"></a>SDWenImageManager属性</h2><figure class="highlight objectivec"><figcaption><span>属性</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">概述了SDWenImageManager的作用,其实UIImageVIew+WebCache这个Category背后执行操作的就是这个SDWebImageManager.它会绑定一个下载器也就是SDwebImageDownloader和一个缓存SDImageCache</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/*若图片不在cache中,就根据给定的URL下载图片,否则返回cache中的图片 */</span></div></pre></td></tr></table></figure><h2 id="SDWebImageOptions"><a href="#SDWebImageOptions" class="headerlink" title="SDWebImageOptions"></a>SDWebImageOptions</h2><p>SDWebImageOptions作为下载的选项提供了非常多的子项，用法和注意事项我都写在代码的注释中了：</p><figure class="highlight objectivec"><figcaption><span>SDWebImageOptions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying.</span></div><div class="line"><span class="comment">     * This flag disable this blacklisting.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 每一个下载都会提供一个URL，如果这个URL是错误，SD就会把它放入到黑名单之中，</span></div><div class="line">    <span class="comment">/// 黑名单中的URL是不会再次进行下载的,但是，当设置了该选项时，SD会将其在黑名单中移除，重新下载该URL，</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span></div><div class="line"><span class="comment">     * leading to delayed download on UIScrollView deceleration for instance.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 一般来说，下载都是按照一定的先后顺序开始的，但是该选项能够延迟下载，也就说他的权限比较低，权限比他高的在他前边下载</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * This flag disables on-disk caching</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 该选项要求SD只把图片缓存到内存中，不缓存到disk中</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span></div><div class="line"><span class="comment">     * By default, the image is only displayed once completely downloaded.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 给下载添加进度</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span></div><div class="line"><span class="comment">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span></div><div class="line"><span class="comment">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span></div><div class="line"><span class="comment">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Use this flag only if you can't make your URLs static with embedded cache busting parameter.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 有这么一种使用场景，如果一个图片的资源发生了改变。但是url并没有变，我们就可以使用该选项来刷新数据了</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span></div><div class="line"><span class="comment">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 支持切换到后台也能下载</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Handles cookies stored in NSHTTPCookieStore by setting</span></div><div class="line"><span class="comment">     * NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 使用Cookies</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Enable to allow untrusted SSL certificates.</span></div><div class="line"><span class="comment">     * Useful for testing purposes. Use with caution in production.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 允许验证证书</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, images are loaded in the order in which they were queued. This flag moves them to</span></div><div class="line"><span class="comment">     * the front of the queue.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 高权限</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span></div><div class="line"><span class="comment">     * of the placeholder image until after the image has finished loading.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 一般情况下，placeholder image 都会在图片下载完成前显示，该选项将设置placeholder image在下载完成之后才能显示</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * We usually don't call transformDownloadedImage delegate method on animated images,</span></div><div class="line"><span class="comment">     * as most transformation code would mangle it.</span></div><div class="line"><span class="comment">     * Use this flag to transform them anyway.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 使用该属性来自由改变图片，但需要使用transformDownloadedImage delegate</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, image is added to the imageView after download. But in some cases, we want to</span></div><div class="line"><span class="comment">     * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)</span></div><div class="line"><span class="comment">     * Use this flag if you want to manually set the image in the completion when success</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 该选项允许我们在图片下载完成后不会立刻给view设置图片，比较常用的使用场景是给赋值的图片添加动画</span></div><div class="line">    SDWebImageAvoidAutoSetImage = <span class="number">1</span> &lt;&lt; <span class="number">11</span>,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, images are decoded respecting their original size. On iOS, this flag will scale down the</span></div><div class="line"><span class="comment">     * images to a size compatible with the constrained memory of devices.</span></div><div class="line"><span class="comment">     * If `SDWebImageProgressiveDownload` flag is set the scale down is deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/// 压缩大图片</span></div><div class="line">    SDWebImageScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">12</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="SDWenImageManager初始化方法"><a href="#SDWenImageManager初始化方法" class="headerlink" title="SDWenImageManager初始化方法"></a>SDWenImageManager初始化方法</h2><figure class="highlight objectivec"><figcaption><span>初始化方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">*初始化方法</span></div><div class="line"><span class="comment">*1.获得一个SDImageCache的单例</span></div><div class="line"><span class="comment">*2.获得一个SDWebImageDownloader的单例</span></div><div class="line"><span class="comment">*3.新建一个MutableSet来存储下载失败的url</span></div><div class="line"><span class="comment">*4.新建一个用来存储下载operation的可遍数组</span></div><div class="line"><span class="comment">*/</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="cacheKeyForURL"><a href="#cacheKeyForURL" class="headerlink" title="cacheKeyForURL"></a>cacheKeyForURL</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果检测到cacheKeyFilter不为空的时候,利用cacheKeyFilter来生成一个key</span></div><div class="line"><span class="comment">//如果为空,那么直接返回URL的string内容,当做key.</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheKeyFilter) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cacheKeyFilter(url);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> [url absoluteString];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="检查图片是否缓存"><a href="#检查图片是否缓存" class="headerlink" title="检查图片是否缓存"></a>检查图片是否缓存</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line">  <span class="comment">//调用上面的方法取到image的url对应的key</span></div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"><span class="comment">//首先检测内存缓存中时候存在这张图片,如果已有直接返回yes </span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.imageCache imageFromMemoryCacheForKey:key] != <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line"><span class="comment">//如果内存缓存里面没有这张图片,那么就调用diskImageExistsWithKey这个方法去硬盘找</span></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检测硬盘里是否缓存了图片</span></div><div class="line">- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line"> <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"> <span class="keyword">return</span> [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面两个方法比较类似,都是先根据图片的url创建对应的key第一个方法先用<code>BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil);</code>判断图片有没有在内存缓存中,如果图片在内存缓存中存在,就在主线程里面回调block,如果图片没有在内存缓存中就去查找是不是在磁盘缓存里面,然后在主线程里面回到block，第二个方法只查询图片是否在磁盘缓存里面,然后在主线程里面回调block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> isInMemoryCache = ([<span class="keyword">self</span>.imageCache imageFromMemoryCacheForKey:key] != <span class="literal">nil</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (isInMemoryCache) &#123;</div><div class="line">        <span class="comment">// making sure we call the completion block on the main queue</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">                completionBlock(<span class="literal">YES</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</div><div class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock(isInDiskCache);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</div><div class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock(isInDiskCache);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相关阅读：<br><a href="/2016/08/05/review-SDWebImage-Code/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/07/SDWebImageManager/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/08/SDWebImageDownloader/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/08/SDWebImageDownloaderOperation/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/09/SDWebImageCache/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/10/SDWebImage-other-interested-parties/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们利用&lt;code&gt;SDWebImageManager&lt;/code&gt;能做很多其他的有意思的事情。比如给各种view绑定一个URL，就能显示图片的功能，有了Options，就能满足多种应用场景的图片下载任务。管理Cache和Downloader等。&lt;br&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage 源码阅读记录（一）</title>
    <link href="http://blog.xiaodongwang.com/2016/08/05/17110/"/>
    <id>http://blog.xiaodongwang.com/2016/08/05/17110/</id>
    <published>2016-08-05T09:00:32.000Z</published>
    <updated>2018-05-10T03:19:50.283Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司项目用到SDWebImage（<a href="https://github.com/rs/SDWebImage/tree/3.8.2" target="_blank" rel="external">v3.8.2</a>），来实现聊天图片的缓存，正好有时间，想好好研究下SDWebImage。本文是阅读网上许多关于SDWebImage文章加上个人理解写下的，也方便日后复习。<br><a id="more"></a></p><!-- TOC --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先老套路来介绍一下这个 SDWebImage 这个著名开源框架吧, 这个开源框架的主要作用就是:<br><div class="alert info no-icon"><p>Asynchronous image downloader with cache support with an UIImageView category.</p></div></p><p>一个异步下载图片并且支持缓存的 UIImageView 分类.就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:<br><figure class="highlight objectivec"><figcaption><span>基本方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"url"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</div></pre></td></tr></table></figure></p><p>在看源码之前，先对思维导图、源码结构、运行流程先有个总体把握可以加深我们对后续代码的理解。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><div class="figure fig-100" style="width:;"><a class="fancybox" href="http://oxyk7k4jh.bkt.clouddn.com/2017-12-15-SDWebImageSWDT.png" title="思维导图" data-caption="思维导图" data-fancybox="default" target="_blank" rel="external"><img class="fig-img" src="http://oxyk7k4jh.bkt.clouddn.com/2017-12-15-SDWebImageSWDT.png" alt="思维导图"></a><span class="caption">思维导图</span></div><div style="clear:both;"></div><h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><div class="figure fig-100" style="width:;"><a class="fancybox" href="http://oxyk7k4jh.bkt.clouddn.com/2017-12-05-SDWebImageClassDiagram.png" title="源码结构" data-caption="源码结构" data-fancybox="default" target="_blank" rel="external"><img class="fig-img" src="http://oxyk7k4jh.bkt.clouddn.com/2017-12-05-SDWebImageClassDiagram.png" alt="源码结构"></a><span class="caption">源码结构</span></div><div style="clear:both;"></div><p>源码结构图已经将这个框架是如何组织的基本展现出来, <code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 直接为表层的 UIKit框架提供接口, 而 <code>SDWebImageManger</code> 负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li>Downloader<ul><li>SDWebImageDownloader</li><li>SDWebImageDownloaderOperation</li></ul></li><li>Cache<ul><li>SDImageCache</li></ul></li><li>Utils<ul><li>SDWebImageManager</li><li>SDWebImageDecoder</li><li>SDWebImagePrefetcher</li></ul></li><li>Categories<ul><li>UIView+WebCacheOperation</li><li>UIImageView+WebCache</li><li>UIImageView+HighlightedWebCache</li><li>UIButton+WebCache</li><li>MKAnnotationView+WebCache</li><li>NSData+ImageContentType</li><li>UIImage+GIF</li><li>UIImage+MultiFormat</li><li>UIImage+WebP</li></ul></li><li>Other<ul><li>SDWebImageOperation（协议）</li><li>SDWebImageCompat（宏定义、常量、通用函数）</li></ul></li></ul><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody><tr><td><code>SDWebImageDownloader</code></td><td>是专门用来下载图片和优化图片加载的，跟缓存没有关系</td></tr><tr><td><code>SDWebImageDownloaderOperation</code></td><td>继承于 <code>NSOperation</code>，用来处理下载任务的</td></tr><tr><td><code>SDImageCache</code></td><td>用来处理内存缓存和磁盘缓存（可选)的，其中磁盘缓存是异步进行的，因此不会阻塞主线程</td></tr><tr><td><code>SDWebImageManager</code></td><td>作为 <code>UIImageView+WebCache</code> 背后的默默付出者，主要功能是将图片下载（<code>SDWebImageDownloader</code>）和图片缓存（<code>SDImageCache</code>）两个独立的功能组合起来</td></tr><tr><td><code>SDWebImageDecoder</code></td><td>图片解码器，用于图片下载完成后进行解码</td></tr><tr><td><code>SDWebImagePrefetcher</code></td><td>预下载图片，方便后续使用，图片下载的优先级低，其内部由 <code>SDWebImageManager</code> 来处理图片下载和缓存</td></tr><tr><td><code>UIView+WebCacheOperation</code></td><td>用来记录图片加载的 operation，方便需要时取消和移除图片加载的 operation</td></tr><tr><td><code>UIImageView+WebCache</code></td><td>集成 <code>SDWebImageManager</code> 的图片下载和缓存功能到 <code>UIImageView</code> 的方法中，方便调用方的简单使用</td></tr><tr><td><code>UIImageView+HighlightedWebCache</code></td><td>跟 <code>UIImageView+WebCache</code> 类似，也是包装了 <code>SDWebImageManager</code>，只不过是用于加载 highlighted 状态的图片</td></tr><tr><td><code>UIButton+WebCache</code></td><td>跟 <code>UIImageView+WebCache</code> 类似，集成 <code>SDWebImageManager</code> 的图片下载和缓存功能到 <code>UIButton</code> 的方法中，方便调用方的简单使用</td></tr><tr><td><code>MKAnnotationView+WebCache</code></td><td>跟 UIImageView+WebCache 类似</td></tr><tr><td><code>NSData+ImageContentType</code></td><td>用于获取图片数据的格式（JPEG、PNG等）</td></tr><tr><td><code>UIImage+GIF</code></td><td>用于加载 GIF 动图</td></tr><tr><td><code>UIImage+WebP</code></td><td>用于解码并加载 WebP 图片</td></tr></tbody></table><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>了解了工程目录结构之后，我们就可以看之前跳过的执行流程图了。<br><div class="figure fig-100" style="width:;"><a class="fancybox" href="http://oxyk7k4jh.bkt.clouddn.com/2017-12-05-SDWebImageSequenceDiagram.png" title="运行流程" data-caption="运行流程" data-fancybox="default" target="_blank" rel="external"><img class="fig-img" src="http://oxyk7k4jh.bkt.clouddn.com/2017-12-05-SDWebImageSequenceDiagram.png" alt="运行流程"></a><span class="caption">运行流程</span></div><div style="clear:both;"></div></p><h1 id="核心方法的解析"><a href="#核心方法的解析" class="headerlink" title="核心方法的解析"></a>核心方法的解析</h1><p><code>SDWebImage</code> 的接口简单易用，开发者一句代码就能使用，代码： <code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</code> ，复杂的逻辑和实现都被隐藏在这句代码的后面。各模块独立，Cache缓存模块提供库的内存缓存和可选的磁盘缓存支持，<code>Downloader</code>下载模块提供基于 <code>NSURLSession</code> 和<code>NSOperation</code> 的下载器。<code>SDWebImageManager</code> 则将 <code>Cache</code> 和 <code>Downloader</code> 两个模块很好的整合在一起，提供基于缓存的图片加载功能。最后是使用 <code>Categories</code> 封装了常用 UI 控件的接口。</p><p>我们看UIImageView+WebCache.h文件,我们可以发现为开发者提供了很多类似于下面的这个方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder</div></pre></td></tr></table></figure></p><p>这些方法最终都会调用<code>- sd_setImageWithURL: placeholderImage: options: progress: completed:</code>,这个方法可以算是核心方法,下面我们详细看一下内部实现 。</p><p>代码的第一句是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> sd_cancelCurrentImageLoad];</div></pre></td></tr></table></figure><p>看方法名就知道它的作用，就是取消这个视图 ImageView 正在加载图片的操作，如果这个 ImageView 正在加载图片，保障在开始新的加载图片任务之前，取消掉正在进行的加载操作。</p><p>看下具体的实现代码 <code>UIImageView+WebCache.m</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_cancelCurrentImageLoad &#123;</div><div class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)sd_cancelCurrentAnimationImagesLoad &#123;</div><div class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:<span class="string">@"UIImageViewAnimationImages"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个 key 说明有两个不一样的加载方式，一个是单张图片的，另一个是连续下载多张，放到 <code>NSArray&lt;UIImage *&gt; *animationImages</code> 中。<br>看下取消操作的代码实现，<code>UIView+WebCacheOperation.m</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)operationDictionary &#123;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;</div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)sd_setImageLoadOperation:(<span class="keyword">id</span>)operation forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:key];</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line">    [operationDictionary setObject:operation forKey:key];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// Cancel in progress downloader from queue</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</div><div class="line">                <span class="keyword">if</span> (operation) &#123;</div><div class="line">                    [operation cancel];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</div><div class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">        &#125;</div><div class="line">        [operationDictionary removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中，通过 <code>objc_setAssociatedObject</code>  关联对象的方法，给 <code>UIImageView</code> 动态添加了一个 <code>NSMutableDictionary</code>  的属性。通过 key-value 维护这个 <code>ImageView</code> 已经有了哪些下载操作，如果是数组就是 <code>UIImageViewAnimationImages</code> 否则就是 <code>UIImageViewImageLoad</code> 。最后获得的都是遵从了 <code>&lt;SDWebImageOperation&gt;</code> 协议的对象，可以统一调用定义好的方法 cancel，达到取消下载操作的目的，如果 operation 都被取消了，则删除对应 key 的值。<br>继续看 <code>- (void)sd_setImageWithURL: placeholderImage: options: ;</code> 里的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        <span class="keyword">self</span>.image = placeholder;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果加载图片的选项不是 <code>SDWebImageDelayPlaceholder</code> 则会在主线程中先设置 placeholder 的占位图，<br><code>SDWebImageDelayPlaceholder</code> 的情况后面说。<code>dispatch_main_async_safe</code> 是一个宏定义，点进去一看发现宏是这样定义的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define dispatch_main_sync_safe(block)\</span></div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; <span class="keyword">else</span> &#123;\</div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>相信这个宏的名字已经讲他的作用解释的很清楚了: 因为图像的绘制只能在主线程完成, 所以, <code>dispatch_main_sync_safe</code> 就是为了保证 <code>block</code> 能在主线程中执行.</p><p>下面这段就是这个类中比较关键的代码了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (url) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// check if activityView is enabled or not</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> addActivityIndicator];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            [wself removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</div><div class="line">                &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            [<span class="keyword">self</span> removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>先检查 activityView 是否可用，可用的话给 ImageView 正中间添加一个活动指示器，并旋转，加载图片完成或失败都会清除掉。<code>__weak __typeof(self)wself = self;</code> 避免循环引用，接下来就是调用 <code>SDWebImageManager</code> 的方法 <code>downloadImageWithURL: options: progress: completed:</code>  ，在该方法的 completed  block 回调中，如果 option 是 <code>SDWebImageAvoidAutoSetImage</code> ，就是要求不要给 ImageView 自动设置图片，则只回调 completedBlock 然后 return，否则有 image 就设置给 ImageView 。没有 image 通常就是错误情况，如果 option 是 <code>SDWebImageDelayPlaceholder</code> 则设置占位图（可以设置成提示用户图片没加载出来的图片），最后回调 completedBlock。上面代码最后一句是把这个 operation 存到 ImageView 的 <code>NSMutableDictionary</code> 中，为了之前提到的 <code>[self sd_cancelCurrentImageLoad];</code>  操作准备的。</p><h1 id="完整核心方法注释"><a href="#完整核心方法注释" class="headerlink" title="完整核心方法注释"></a>完整核心方法注释</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(SDWebImageDownloaderProgressBlock)progressBlock </div><div class="line">completed:(SDWebImageCompletionBlock)completedBlock &#123;</div><div class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</div><div class="line">    <span class="comment">//将 url作为属性绑定到ImageView上,用static char imageURLKey作key</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line"><span class="comment">/*options &amp; SDWebImageDelayPlaceholder这是一个位运算的与操作,!(options &amp; SDWebImageDelayPlaceholder)的意思就是options参数不是SDWebImageDelayPlaceholder,就执行以下操作   </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">#define dispatch_main_async_safe(block)\</span></div><div class="line"><span class="comment">    if ([NSThread isMainThread]) &#123;\</span></div><div class="line"><span class="comment">        block();\</span></div><div class="line"><span class="comment">    &#125; else &#123;\</span></div><div class="line"><span class="comment">        dispatch_async(dispatch_get_main_queue(), block);\</span></div><div class="line"><span class="comment">    &#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line">这是一个宏定义,因为图像的绘制只能在主线程完成,所以dispatch_main_sync_safe就是为了保证block在主线程中执行</div><div class="line"> <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line"><span class="comment">//设置imageView的placeHolder</span></div><div class="line">            <span class="keyword">self</span>.image = placeholder;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 检查是否通过`setShowActivityIndicatorView:`方法设置了显示正在加载指示器。如果设置了，使用`addActivityIndicator`方法向self添加指示器</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> addActivityIndicator];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"><span class="comment">//下载的核心方法</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options </div><div class="line">progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">          <span class="comment">//移除加载指示器</span></div><div class="line">            [wself removeActivityIndicator];</div><div class="line">          <span class="comment">//如果imageView不存在了就return停止操作</span></div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">SDWebImageAvoidAutoSetImage,默认情况下图片会在下载完毕后自动添加给imageView,但是有些时候我们想在设置图片之前加一些图片的处理,就要下载成功后去手动设置图片了,不会执行`wself.image = image;`,而是直接执行完成回调，有用户自己决定如何处理。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</div><div class="line">                &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">如果后两个条件中至少有一个不满足，那么就直接将image赋给当前的imageView</span></div><div class="line"><span class="comment">，并调用setNeedsLayout</span></div><div class="line"><span class="comment">*/</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">image为空，并且设置了延迟设置占位图，会将占位图设置为最终的image，，并将其标记为需要重新布局。</span></div><div class="line"><span class="comment">  */</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line"> <span class="comment">// 为UIImageView绑定新的操作,以为之前把ImageView的操作cancel了</span></div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="comment">// 判断url不存在，移除加载指示器，执行完成回调，传递错误信息。</span></div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            [<span class="keyword">self</span> removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>UIImageView+WebCache</code> 类中的代码还是很容易的，逻辑很清晰，没有难懂的地方。请接着下篇 <a href="/2016/08/10/34027/">SDWebImageManager 源码阅读记录（二）</a> 将<code>SDWebImageManager</code>解析核心方法：</p><p>相关阅读：<br><a href="/2016/08/05/17110/">SDWebImage 源码阅读记录（一）</a><br><a href="/2016/08/10/34027/">SDWebImageManager 源码阅读记录（二）</a><br><a href="/2016/08/14/18664/">SDWebImageDownloader 源码阅读记录（三）</a><br><a href="/2016/08/20/56144/">SDWebImageDownloaderOperation 源码阅读记录（四）</a><br><a href="/2016/08/26/28513/">SDWebImageCache 源码阅读记录（五）</a><br><a href="/2016/08/30/9908/">SDWebImage相关类 源码阅读记录（六）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期公司项目用到SDWebImage（&lt;a href=&quot;https://github.com/rs/SDWebImage/tree/3.8.2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;v3.8.2&lt;/a&gt;），来实现聊天图片的缓存，正好有时间，想好好研究下SDWebImage。本文是阅读网上许多关于SDWebImage文章加上个人理解写下的，也方便日后复习。&lt;br&gt;
    
    </summary>
    
      <category term="SDWebImage" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/"/>
    
      <category term="Github" scheme="http://blog.xiaodongwang.com/categories/SDWebImage/Github/"/>
    
    
      <category term="源码阅读" scheme="http://blog.xiaodongwang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>多线程学习总结（GCD，NSOperation）</title>
    <link href="http://blog.xiaodongwang.com/2016/05/10/36425/"/>
    <id>http://blog.xiaodongwang.com/2016/05/10/36425/</id>
    <published>2016-05-10T15:14:32.000Z</published>
    <updated>2018-05-17T12:16:24.372Z</updated>
    
    <content type="html"><![CDATA[<p>网上对于iOS多线程及GCD的文章有很多，经过一番百度（阅读了很多质量层次不齐的文章）之后，作了一些总结，写在下面，跟大家一起来分享一下<br><a id="more"></a><br><!-- TOC --></p><h1 id="何为多线程"><a href="#何为多线程" class="headerlink" title="何为多线程"></a>何为多线程</h1><p>其实，如果不考虑其他任何因素和技术，多线程有百害而无一利，只能浪费时间，降低程序效率。<br>是的，我很清醒的写下这句话。<br>试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务： </p><ol><li>建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。 </li><li>把十个任务放在一个线程里，按顺序执行。</li></ol><p>操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令列”。<br>对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中的值需要不断地被备份、替换。 而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者。</p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>通过刚刚的分析我们看到，多线程本身会带来效率上的损失。准确来说，在处理并发任务时，多线程不仅不能提高效率，反而还会降低程序效率。</p><p>所谓的“并发”，英文翻译是concurrent。要注意和“并行（parallelism）”的区别。</p><div class="alert info no-icon"><p>并发指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。</p></div><p>比如有很多人排队等待检票，这一现象就可以理解为并发。<br><div class="alert info no-icon"><p>并行指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。</p></div></p><p>比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。</p><p>并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p><p>我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用foo()方法，那么程序运行到第二行的时候，foo方法肯定是执行完了。</p><p>所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。</p><p>比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。</p><h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>假设现在有三个任务需要处理。假设单个CPU处理它们分别需要3、1、1秒。</p><p>并行与串行，其实讨论的是处理这三个任务的速度问题。如果三个CPU并行处理，那么一共只需要3秒。相比于串行处理，节约了两秒。</p><p>而同步/异步，其实描述的是任务之间先后顺序问题。假设需要三秒的那个是保存数据的任务，而另外两个是UI相关的任务。那么通过异步执行第一个任务，我们省去了三秒钟的卡顿时间。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>对于同步执行的三个任务来说，系统倾向于在同一个线程里执行它们。因为即使开了三个线程，也得等他们分别在各自的线程中完成。并不能减少总的处理时间，反而徒增了线程切换（这就是文章开头举的例子）</p><p>对于异步执行的三个任务来说，系统倾向于在三个新的线程里执行他们。因为这样可以最大程度的利用CPU性能，提升程序运行效率。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>于是我们可以得出结论，在需要同时处理IO和UI的情况下，真正起作用的是异步，而不是多线程。可以不用多线程（因为处理UI非常快），但不能不用异步（否则的话至少要等IO结束）。</p><p>注意到我把“倾向于”这三个加粗了，也就是说异步方法并不一定永远在新线程里面执行，反之亦然。在接下来关于GCD的部分会对此做出解释。</p><h1 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h1><p>GCD以block为基本单位，一个block中的代码可以为一个任务。下文中提到任务，可以理解为执行某个block<br>同时，GCD中有两大最重要的概念，分别是“队列”和“执行方式”。<br>使用block的过程，概括来说就是把block放进合适的队列，并选择合适的执行方式去执行block的过程。</p><h2 id="队列总的来说可以分为三种："><a href="#队列总的来说可以分为三种：" class="headerlink" title="队列总的来说可以分为三种："></a>队列总的来说可以分为三种：</h2><ol><li>串行队列（先进入队列的任务先出队列，每次只执行一个任务）</li><li>并发队列（依然是“先入先出”，不过可以形成多个任务并发）</li><li>主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）</li></ol><h2 id="两种基本的执行方式"><a href="#两种基本的执行方式" class="headerlink" title="两种基本的执行方式"></a>两种基本的执行方式</h2><ol><li>同步执行</li><li>异步执行</li></ol><table><thead><tr><th>外围线程</th><th>执行模式</th><th>执行队列</th><th>内部执行任务的线程</th></tr></thead><tbody><tr><td>主线程</td><td>同步</td><td>并行队列</td><td>主线程</td></tr><tr><td>主线程</td><td>异步</td><td>并行队列</td><td>多个次线程</td></tr><tr><td>主线程</td><td>同步</td><td>串行队列</td><td>主线程</td></tr><tr><td>主线程</td><td>异步</td><td>串行队列</td><td>多个次线程</td></tr><tr><td>次线程</td><td>同步</td><td>主队列</td><td>主线程</td></tr><tr><td>次线程</td><td>异步</td><td>主队列</td><td>主线程</td></tr></tbody></table><p>可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。<br>然而事实上，在本文一开始就揭开了“多线程”的神秘面纱，所以我们在编程时，更应该考虑的是：</p><div class="alert info no-icon"><p><em>同步 Or 异步</em></p></div><p>以及<br><div class="alert info no-icon"><p><em>串行 Or 并行</em></p></div><br>而非仅仅考虑是否新开线程。<br>当然，了解任务运行在那个线程中也是为了更加深入的理解整个程序的运行情况，尤其是接下来要讨论的死锁问题。</p><h2 id="GCD的死锁问题"><a href="#GCD的死锁问题" class="headerlink" title="GCD的死锁问题"></a>GCD的死锁问题</h2><p>在使用GCD的过程中，如果向当前串行队列中同步派发一个任务，就会导致死锁。<br>这句话有点绕，我们首先举个例子看看：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">   <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">       <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">           <span class="built_in">NSLog</span>(<span class="string">@"这里死锁了"</span>);</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码就会导致死锁，因为我们目前在主队列中，又将要同步地添加一个block到主队列(串行)中。</p><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><p>我们知道<code>dispatch_sync</code>表示同步的执行任务，也就是说执行<code>dispatch_sync</code>后，当前队列会阻塞。而<code>dispatch_sync</code>中的block如果要在当前队列中执行，就得等待当前队列程执行完成。<br>在上面这个例子中，主队列在执行<code>dispatch_sync</code>，随后队列中新增一个任务block。因为主队列是同步队列，所以block要等<code>dispatch_sync</code>执行完才能执行，但是<code>dispatch_sync</code>是同步派发，要等block执行完才算是结束。在主队列中的两个任务互相等待，导致了死锁。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实在通常情况下我们不必要用<code>dispatch_sync</code>，因为<code>dispatch_async</code>能够更好的利用CPU，提升程序运行速度。<br>只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用<code>dispatch_sync</code>。在使用<code>dispatch_sync</code>的时候应该分析当前处于哪个队列，以及任务会提交到哪个队列。</p><h2 id="GCD任务组"><a href="#GCD任务组" class="headerlink" title="GCD任务组"></a>GCD任务组</h2><p>了解完队列之后，很自然的会有一个想法：我们怎么知道所有任务都已经执行完了呢？<br>在单个串行队列中，这个不是问题，因为只要把回调block添加到队列末尾即可。<br>但是对于并行队列，以及多个串行、并行队列混合的情况，就需要使用dispatch_group了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"wxd.queue.next"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    </div><div class="line">    dispatch_group_async(group, serialQueue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"group-serial - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, serialQueue, ^&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"group-02 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_notify(group, serialQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先我们要通过<code>dispatch_group_create()</code>方法生成一个组。<br>接下来，我们把<code>dispatch_async</code>方法换成<code>dispatch_group_async</code>。这个方法多了一个参数，第一个参数填刚刚创建的分组。<br>想问<code>dispatch_sync</code>对应的分组方法是什么的童鞋面壁思过三秒钟，思考一下group出现的目的和<code>dispatch_sync</code>的特点。<br>最后调用<code>dispatch_group_notify</code>方法。这个方法表示把第三个参数block传入第二个参数队列中去。而且可以保证第三个参数block执行时，group中的所有任务已经全部完成。</p><h3 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h3><p><code>dispatch_group_wait</code>方法是一个很有用的方法，它的完整定义如下：<br><code>dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</code><br>第一个参数表示要等待的group，第二个则表示等待时间。返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。<br>第二个<code>dispatch_time_t</code>类型的参数还有两个特殊值：<code>DISPATCH_TIME_NOW</code>和<code>DISPATCH_TIME_FOREVER</code>。<br>前者表示立刻检查属于这个group的任务是否已经完成，后者则表示一直等到属于这个group的任务全部完成。</p><h2 id="dispatch-after方法"><a href="#dispatch-after方法" class="headerlink" title="dispatch_after方法"></a>dispatch_after方法</h2><p>通过GCD还可以进行简单的定时操作，比如在1秒后执行某个block。代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"延迟0.5秒后执行"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><code>dispatch_after</code>方法有三个参数。第一个表示时间，也就是从现在起往后三秒钟。第二三个参数分别表示要提交的任务和提交到哪个队列。<br>需要注意的是<code>dispatch_after</code>仅表示在指定时间后提交任务，而非执行任务。如果任务提交到主队列，它将在main runloop中执行，对于每隔1/60秒执行一次的RunLoop，任务最多有可能在3+1/60秒后执行。</p><h2 id="dispathc-once方法"><a href="#dispathc-once方法" class="headerlink" title="dispathc_once方法"></a>dispathc_once方法</h2><p>首先我们来看一下最简单的<code>dispathc_once</code>函数，这在单例模式中被广泛使用。<br><code>dispathc_once</code>函数可以确保某个block在应用程序执行的过程中只被处理一次，而且它是线程安全的。所以单例模式可以很简单的实现，以OC中Manager类为例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (Manager *)sharedInstance &#123;</div><div class="line">    <span class="keyword">static</span> Manager *sharedManagerInstance = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_once</span>($once, ^&#123;</div><div class="line">        sharedManagerInstance = [[Manager alloc] init];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sharedManagerInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码中我们创建一个值为nil的<code>sharedManagerInstance</code>静态对象，然后把它的初始化代码放到<code>dispatch_once</code>中完成。<br>这样，只有第一次调用<code>sharedInstance</code>方法时才会进行对象的初始化，以后每次只是返回<code>sharedManagerInstance</code>而已。</p><h2 id="dispatch-barrier-async方法"><a href="#dispatch-barrier-async方法" class="headerlink" title="dispatch_barrier_async方法"></a>dispatch_barrier_async方法</h2><p>我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。<br>这样的需求比较常见，GCD提供了一个非常简单的解决办法——<code>dispatch_barrier_async</code><br>假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(<span class="string">"wxd.queue.concurrent"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</div><div class="line">dispatch_async(concurrentQueue, ^&#123; @<span class="string">"任务1"</span> &#125;);</div><div class="line">dispatch_async(concurrentQueue, ^&#123; @<span class="string">"任务2"</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">    这里插入写入任务，比如：</span></div><div class="line"><span class="comment">    dispatch_async(concurrentQueue, ^&#123;  &#125;);</span></div><div class="line"><span class="comment">*/</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123; @<span class="string">"任务3"</span> &#125;);</div><div class="line">dispatch_async(concurrentQueue, ^&#123; @<span class="string">"任务4"</span> &#125;);</div></pre></td></tr></table></figure><p>如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。<br>如果使用dispatch_barrier_async函数，代码就可以这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123; <span class="string">@"任务1"</span> &#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123; <span class="string">@"任务2"</span> &#125;);</div><div class="line"></div><div class="line">dispatch_barrier_async(concurrentQueue, block_for_writing)</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123; <span class="string">@"任务3"</span> &#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123; <span class="string">@"任务4"</span> &#125;);</div></pre></td></tr></table></figure><p>dispatch_barrier_async会把并行队列的运行周期分为这三个过程：</p><ol><li>首先等目前追加到并行队列中所有任务都执行完成</li><li>开始执行<code>dispatch_barrier_async</code>中的任务，这时候即使向并行队列提交任务，也不会执行</li><li><code>dispatch_barrier_async</code>中的任务执行完成后，并行队列恢复正常。</li></ol><p>总的来说，<code>dispatch_barrier_async</code>起到了“承上启下”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。<br>这样一来，使用并行队列和<code>dispatc_barrier_async</code>方法，就可以高效的进行数据和文件读写了。</p><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><p>经过上面的学习，我们已经理解了多线程编程的基本概念，以及GCD的简单使用。这一部分将会介绍NSOperation和NSOperationQueue。主要涉及这几个方面：</p><ol><li>NSOperation和NSOperationQueue用法介绍</li><li>NSOperation的暂停、恢复和取消</li><li>通过KVO对NSOperation的状态进行检测</li><li>多个NSOperation的之间的依赖关系</li></ol><p>从简单意义上来说，<code>NSOperation</code>是对GCD中的block进行的封装，它也表示一个要被执行的任务。<br>与GCD中的block类似，<code>NSOperation</code>对象有一个<code>start()</code>方法表示开始执行这个任务。<br>不仅如此，<code>NSOperation</code>表示的任务还可以被取消。它还有三种状态<code>isExecuted</code>、<code>isFinished</code>和<code>isCancelled</code>以方便我们通过KVC对它的状态进行监听。<br>想要开始执行一个任务可以这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;];</div><div class="line">[op addExecutionBlock:^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"execution block1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;];</div><div class="line">[op start];</div></pre></td></tr></table></figure><p>以上代码会得到这样的执行结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSBlockOperation</span> - &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000007ba00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">execution block1 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x604000268b40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</div></pre></td></tr></table></figure><p>首先我们创建了一个<code>NSBlockOperation</code>，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。<br>用<code>NSBlockOperation</code>是因为<code>NSOperation</code>是一个基类，不应该直接生成<code>NSOperation</code>对象，而是应该用它的子类。<code>NSBlockOperation</code>是苹果预定义的子类，它可以用来封装一个或多个block，后面会介绍如何自己创建<code>NSOperation</code>的子类。<br>同时，还可以调用<code>addExecutionBlock</code>方法追加几个任务，这些任务会并行执行（也就是说很有可能运行在别的线程里）。<br>最后，调用<code>start</code>方法让<code>NSOperation</code>方法运行起来。<code>start</code>是一个同步方法。</p><h2 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h2><p>刚刚我们知道，默认的<code>NSOperation</code>是同步执行的。简单的看一下<code>NSOperation</code>类的定义会发现它有一个只读属性<code>asynchronous</code><br>这意味着如果想要异步执行，就需要自定义<code>NSOperation</code>的子类。或者使用<code>NSOperationQueue</code><br><code>NSOperationQueue</code>类似于GCD中的队列。我们知道GCD中的队列有三种：主队列、串行队列和并行队列。<code>NSOperationQueue</code>更简单，只有两种：主队列和非主队列。<br>我们自己生成的<code>NSOperationQueue</code>对象都是非主队列，主队列可以用<code>NSOperationQueue.mainQueue</code>取得。<br>NSOperationQueue的主队列是串行队列，而且其中所有<code>NSOperation</code>都会在主线程中执行。<br>对于非主队列来说，一旦一个<code>NSOperation</code>被放入其中，那这个<code>NSOperation</code>一定是并发执行的。因为<code>NSOperationQueue</code>会为每一个<code>NSOperation</code>创建线程并调用它的<code>start</code>方法。<br><code>NSOperationQueue</code>有一个属性叫<code>maxConcurrentOperationCount</code>，它表示最多支持多少个<code>NSOperation</code>并发执行。如果<code>maxConcurrentOperationCount</code>被设为1，就以为这个队列是串行队列。<br>因此，<code>NSOperationQueue</code>和<code>GCD</code>中的队列有这样的对应关系：</p><table><thead><tr><th></th><th>NSOperationQueue</th><th>GCD </th></tr></thead><tbody><tr><td> 主队列</td><td>NSOperationQueue.mainQueue</td><td>dispatch_get_main_queue()</td></tr><tr><td>串行队列</td><td>自建队列maxConcurrentOperationCount为1</td><td>dispatch_queue_create(“”, DISPATCH_QUEUE_SERIAL)</td></tr><tr><td>并发队列</td><td>自建队列maxConcurrentOperationCount大于1</td><td>dispatch_queue_create(“”, DISPATCH_QUEUE_CONCURRENT)</td></tr></tbody></table><p>回到开头的问题，如何利用NSOperationQueue实现异步操作呢，代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">let operation = <span class="built_in">NSBlockOperation</span> ()  </div><div class="line">operation.addExecutionBlock &#123; () -&gt; Void <span class="keyword">in</span>  </div><div class="line">    print(<span class="string">"exec block1 -- \(NSThread.currentThread())"</span>)</div><div class="line">&#125;</div><div class="line">operation.addExecutionBlock &#123; () -&gt; Void <span class="keyword">in</span>  </div><div class="line">    print(<span class="string">"exec block2 -- \(NSThread.currentThread())"</span>)</div><div class="line">&#125;</div><div class="line">operation.addExecutionBlock &#123; () -&gt; Void <span class="keyword">in</span>  </div><div class="line">    print(<span class="string">"exec block3 -- \(NSThread.currentThread())"</span>)</div><div class="line">&#125;</div><div class="line">operationQueue.addOperation(operation)  </div><div class="line">print(<span class="string">"操作结束"</span>)</div></pre></td></tr></table></figure></p><p>得到运行结果如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exec block1 -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x125672f10</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;  </div><div class="line">exec block2 -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x12556ba40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;  </div><div class="line">exec block3 -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x125672f10</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</div></pre></td></tr></table></figure></p><p>使用<code>NSOperationQueue</code>来执行任务与之前的区别在于，首先创建一个非主队列。然后用<code>addOperation</code>方法替换之前的<code>start</code>方法。刚刚已经说过，<code>NSOperationQueue</code>会为每一个<code>NSOperation</code>建立线程并调用他们的<code>start</code>方法。<br>观察一下运行结果，所有的<code>NSOperation</code>都没有在主线程执行，从而成功的实现了异步、并行处理。</p><h2 id="NSOperation新特性"><a href="#NSOperation新特性" class="headerlink" title="NSOperation新特性"></a>NSOperation新特性</h2><p>在学习<code>NSOperation</code>的时候，我们总是用GCD的概念去解释。但是<code>NSOperation</code>作为对<code>GCD</code>更高层次的封装，它有着一些GCD无法实现（或者至少说很难实现）的特性。由于<code>NSOperation</code>和<code>NSOperationQueue</code>良好的封装，这些新特性的使用都非常简单。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个<code>NSOperation</code>。<br>当某个<code>NSOperation</code>被取消时，我们应该尽可能的清除<code>NSOperation</code>内部的数据并且把<code>cancelled</code>和<code>finished</code>设为<code>true</code>，把<code>executing</code>设为<code>false</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取消某个NSOperation</span></div><div class="line">operation1.cancel()</div><div class="line"><span class="comment">//取消某个NSOperationQueue剩余的NSOperation</span></div><div class="line">queue.cencelAllOperations()</div></pre></td></tr></table></figure><h3 id="设置依赖"><a href="#设置依赖" class="headerlink" title="设置依赖"></a>设置依赖</h3><p>依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到<code>NSOperationQueue</code>的并发特性（因为可能不止这两个任务）。<br>这时候我们可以设置<code>NSOperation</code>之间的依赖关系。语法非常简洁：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operation2.addDependency(operation1)</div></pre></td></tr></table></figure></p><p>需要注意的是NSOperation之间的相互依赖会导致死锁</p><h3 id="NSOperationQueue的暂停与恢复"><a href="#NSOperationQueue的暂停与恢复" class="headerlink" title="NSOperationQueue的暂停与恢复"></a>NSOperationQueue的暂停与恢复</h3><p>这个更加简单，只要修改suspended属性即可</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue.suspended = <span class="literal">true</span> <span class="comment">//暂停queue中所有operation  </span></div><div class="line">queue.suspended = <span class="literal">false</span> <span class="comment">//恢复queue中所有operation</span></div></pre></td></tr></table></figure><h2 id="NSOperation的优先级"><a href="#NSOperation的优先级" class="headerlink" title="NSOperation的优先级"></a>NSOperation的优先级</h2><p>GCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑<code>NSOperation</code>的优先级<br><code>NSOperation</code>有一个<code>NSOperationQueuePriority</code>枚举类型的属性<code>queuePriority</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">enum</span> <span class="built_in">NSOperationQueuePriority</span> : Int &#123;  </div><div class="line">    <span class="keyword">case</span> VeryLow</div><div class="line">    <span class="keyword">case</span> Low</div><div class="line">    <span class="keyword">case</span> Normal</div><div class="line">    <span class="keyword">case</span> High</div><div class="line">    <span class="keyword">case</span> VeryHigh</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要注意的是，NSOperationQueue也不能完全保证优先级高的任务一定先执行。</p><h2 id="NSOperation和GCD如何选择"><a href="#NSOperation和GCD如何选择" class="headerlink" title="NSOperation和GCD如何选择"></a>NSOperation和GCD如何选择</h2><p>GCD以block为单位，代码简洁。同时GCD中的<code>队列</code>、<code>组</code>、<code>信号量</code>、<code>source</code>、<code>barriers</code>都是组成并行编程的基本原语。对于一次性的计算，或是仅仅为了加快现有方法的运行速度，选择轻量化的GCD就更加方便。<br>而<code>NSOperation</code>可以用来规划一组任务之间的依赖关系，设置它们的优先级，任务能被取消。队列可以暂停、恢复。<code>NSOperation</code>还可以被子类化。这些都是GCD所不具备的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实经过上门的分析，我们大概对<code>NSOperation</code>和<code>GCD</code>都有了比较详细的了解，同时在亲自运用这两者的过程中有了自己的理解。NSOperation是对GCD更高层次的封装，提供了任务的取消、暂停、恢复功能。但GCD因为更加接近底层，所以也有自己的优势。NSOperation和GCD并不是互斥的，有效地结合两者可以开发出更棒的应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上对于iOS多线程及GCD的文章有很多，经过一番百度（阅读了很多质量层次不齐的文章）之后，作了一些总结，写在下面，跟大家一起来分享一下&lt;br&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://blog.xiaodongwang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://blog.xiaodongwang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/iOS/"/>
    
      <category term="GCD" scheme="http://blog.xiaodongwang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/iOS/GCD/"/>
    
    
      <category term="多线程" scheme="http://blog.xiaodongwang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>乃心</title>
    <link href="http://blog.xiaodongwang.com/2016/04/20/56707/"/>
    <id>http://blog.xiaodongwang.com/2016/04/20/56707/</id>
    <published>2016-04-19T16:00:00.000Z</published>
    <updated>2018-05-14T09:01:11.271Z</updated>
    
    <content type="html"><![CDATA[<p>人生中最美好的就是和你爱着的人，一起看过的风景，还有一路留下的记忆.<br><a id="more"></a><br>为你漫天繁星而来，你却给我无限惊喜.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生中最美好的就是和你爱着的人，一起看过的风景，还有一路留下的记忆.&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.xiaodongwang.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="记录" scheme="http://blog.xiaodongwang.com/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="云南" scheme="http://blog.xiaodongwang.com/tags/%E4%BA%91%E5%8D%97/"/>
    
  </entry>
  
</feed>
